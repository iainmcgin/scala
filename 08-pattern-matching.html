<!DOCTYPE HTML>
<html lang="en-US">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Pattern Matching | The Scala Language Specification 2.11</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="iainmcgin">
        <meta name="description" content="Scala is a Java-like programming language which unifies
object-oriented and functional programming.  It is a pure
object-oriented language in the sense that every value is an
object. Types and behavior of objects are described by
classes. Classes can be composed using mixin composition.  Scala is
designed to work seamlessly with less pure but mainstream
object-oriented languages like Java.">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="./09-top-level-definitions.html" />
        
        
        <link rel="prev" href="./07-implicit-parameters-and-views.html" />
        

        <meta property="og:title" content="Pattern Matching | The Scala Language Specification 2.11">
        <meta property="og:site_name" content="The Scala Language Specification 2.11">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/iainmcgin">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

          <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [['$','$'], ['\\(','\\)']],
              skipTags: ['script', 'noscript', 'style', 'textarea'],
              processEscapes: true
            }
          });
          </script>
          <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

          <!--
          <script type="text/javascript">
            // clear content of H3 nodes that start with "Example:"
            // the content is only there to determine ID of the H3 element (redcarpet doesn't let us set css id)
            $( document ).ready(function(){ $("h3[id*='example']").text("") })
          </script>
          -->
        
    </head>
    <body>
        
    <div class="book" data-github="iainmcgin/scala" data-level="8" data-basepath="." data-revision="1397801841390">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/iainmcgin/scala" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    
    <a href="https://github.com/iainmcgin/scala/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/iainmcgin/scala/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1><a href="./" >The Scala Language Specification 2.11</a></h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/iainmcgin" target="blank">About the author</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/issues" target="blank">Questions and Issues</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/edit/master/08-pattern-matching.md" target="blank">Edit and Contribute</a>
        </li>
        <li class="divider"></li>
        
        <li data-level="0" data-path="index.html">
            <a href="./"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li  data-level="1" data-path="01-lexical-syntax.html">
                
                <a href="./01-lexical-syntax.html">
                    <i class="fa fa-check"></i> <b>1.</b> Lexical Syntax
                </a>
                
                
            </li>
        
            <li  data-level="2" data-path="02-identifiers-names-and-scopes.html">
                
                <a href="./02-identifiers-names-and-scopes.html">
                    <i class="fa fa-check"></i> <b>2.</b> Identifiers, Names &amp; Scopes
                </a>
                
                
            </li>
        
            <li  data-level="3" data-path="03-types.html">
                
                <a href="./03-types.html">
                    <i class="fa fa-check"></i> <b>3.</b> Types
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="04-basic-declarations-and-definitions.html">
                
                <a href="./04-basic-declarations-and-definitions.html">
                    <i class="fa fa-check"></i> <b>4.</b> Basic Declarations &amp; Definitions
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="05-classes-and-objects.html">
                
                <a href="./05-classes-and-objects.html">
                    <i class="fa fa-check"></i> <b>5.</b> Classes and Objects
                </a>
                
                
            </li>
        
            <li  data-level="6" data-path="06-expressions.html">
                
                <a href="./06-expressions.html">
                    <i class="fa fa-check"></i> <b>6.</b> Expressions
                </a>
                
                
            </li>
        
            <li  data-level="7" data-path="07-implicit-parameters-and-views.html">
                
                <a href="./07-implicit-parameters-and-views.html">
                    <i class="fa fa-check"></i> <b>7.</b> Implicit Patterns &amp; Views
                </a>
                
                
            </li>
        
            <li  data-level="8" data-path="08-pattern-matching.html">
                
                <a href="./08-pattern-matching.html">
                    <i class="fa fa-check"></i> <b>8.</b> Pattern Matching
                </a>
                
                
            </li>
        
            <li  data-level="9" data-path="09-top-level-definitions.html">
                
                <a href="./09-top-level-definitions.html">
                    <i class="fa fa-check"></i> <b>9.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="10" data-path="10-xml-expressions-and-patterns.html">
                
                <a href="./10-xml-expressions-and-patterns.html">
                    <i class="fa fa-check"></i> <b>10.</b> XML Expressions &amp; Patterns
                </a>
                
                
            </li>
        
            <li  data-level="11" data-path="11-user-defined-annotations.html">
                
                <a href="./11-user-defined-annotations.html">
                    <i class="fa fa-check"></i> <b>11.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="12" data-path="12-the-scala-standard-library.html">
                
                <a href="./12-the-scala-standard-library.html">
                    <i class="fa fa-check"></i> <b>12.</b> The Scala Standard Library
                </a>
                
                
            </li>
        
            <li  data-level="13" data-path="13-syntax-summary.html">
                
                <a href="./13-syntax-summary.html">
                    <i class="fa fa-check"></i> <b>13.</b> Syntax Summary
                </a>
                
                
            </li>
        
            <li  data-level="14" data-path="14-references.html">
                
                <a href="./14-references.html">
                    <i class="fa fa-check"></i> <b>14.</b> References
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 92.85714285714286%;min-width: 85.71428571428571%;"></div>
    </div>
    <div class="chapters">
    
        <a href="./index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="./01-lexical-syntax.html" title="Lexical Syntax" class="chapter done new-chapter" data-progress="1" style="left: 7.142857142857143%;"></a>
    
        <a href="./10-xml-expressions-and-patterns.html" title="XML Expressions &amp; Patterns" class="chapter done " data-progress="10" style="left: 14.285714285714286%;"></a>
    
        <a href="./11-user-defined-annotations.html" title="Top Level Definitions" class="chapter done " data-progress="11" style="left: 21.428571428571427%;"></a>
    
        <a href="./12-the-scala-standard-library.html" title="The Scala Standard Library" class="chapter done " data-progress="12" style="left: 28.571428571428573%;"></a>
    
        <a href="./13-syntax-summary.html" title="Syntax Summary" class="chapter done " data-progress="13" style="left: 35.714285714285715%;"></a>
    
        <a href="./14-references.html" title="References" class="chapter done " data-progress="14" style="left: 42.857142857142854%;"></a>
    
        <a href="./02-identifiers-names-and-scopes.html" title="Identifiers, Names &amp; Scopes" class="chapter done new-chapter" data-progress="2" style="left: 50%;"></a>
    
        <a href="./03-types.html" title="Types" class="chapter done new-chapter" data-progress="3" style="left: 57.142857142857146%;"></a>
    
        <a href="./04-basic-declarations-and-definitions.html" title="Basic Declarations &amp; Definitions" class="chapter done new-chapter" data-progress="4" style="left: 64.28571428571429%;"></a>
    
        <a href="./05-classes-and-objects.html" title="Classes and Objects" class="chapter done new-chapter" data-progress="5" style="left: 71.42857142857143%;"></a>
    
        <a href="./06-expressions.html" title="Expressions" class="chapter done new-chapter" data-progress="6" style="left: 78.57142857142857%;"></a>
    
        <a href="./07-implicit-parameters-and-views.html" title="Implicit Patterns &amp; Views" class="chapter done new-chapter" data-progress="7" style="left: 85.71428571428571%;"></a>
    
        <a href="./08-pattern-matching.html" title="Pattern Matching" class="chapter done new-chapter" data-progress="8" style="left: 92.85714285714286%;"></a>
    
        <a href="./09-top-level-definitions.html" title="Top Level Definitions" class="chapter  new-chapter" data-progress="9" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_7">
                    
                        <h1 id="8-pattern-matching">8. Pattern Matching</h1>
<h2 id="patterns">Patterns</h2>
<pre><code class="lang-ebnf">  Pattern         ::=  Pattern1 { ‘|’ Pattern1 }
  Pattern1        ::=  varid ‘:’ TypePat
                    |  ‘_’ ‘:’ TypePat
                    |  Pattern2
  Pattern2        ::=  varid [‘@’ Pattern3]
                    |  Pattern3
  Pattern3        ::=  SimplePattern 
                    |  SimplePattern {id [nl] SimplePattern}
  SimplePattern   ::=  ‘_’
                    |  varid
                    |  Literal
                    |  StableId
                    |  StableId ‘(’ [Patterns] ‘)’
                    |  StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’
                    |  ‘(’ [Patterns] ‘)’
                    |  XmlPattern
  Patterns        ::=  Pattern {‘,’ Patterns}
</code></pre>
<p>A pattern is built from constants, constructors, variables and type
tests. Pattern matching tests whether a given value (or sequence of values)
has the shape defined by a pattern, and, if it does, binds the
variables in the pattern to the corresponding components of the value
(or sequence of values).  The same variable name may not be bound more
than once in a pattern.</p>
<h6 id="example">Example</h6>
<p>Some examples of patterns are:</p>
<ol>
<li>The pattern <code>ex: IOException</code> matches all instances of class
   <code>IOException</code>, binding variable <code>ex</code> to the instance.</li>
<li>The pattern <code>Some(x)</code> matches values of the form <code>Some($v$)</code>,
   binding <code>x</code> to the argument value $v$ of the <code>Some</code> constructor.</li>
<li>The pattern <code>(x, _)</code> matches pairs of values, binding <code>x</code> to
   the first component of the pair. The second component is matched
   with a wildcard pattern.</li>
<li>The pattern <code>x :: y :: xs</code> matches lists of length $\geq 2$,
   binding <code>x</code> to the list&#39;s first element, <code>y</code> to the list&#39;s
   second element, and <code>xs</code> to the remainder.</li>
<li>The pattern <code>1 | 2 | 3</code> matches the integers between 1 and 3.</li>
</ol>
<p>Pattern matching is always done in a context which supplies an
expected type of the pattern. We distinguish the following kinds of
patterns.</p>
<h3 id="variable-patterns">Variable Patterns</h3>
<pre><code class="lang-ebnf">  SimplePattern   ::=  `_&#39;
                    |  varid
</code></pre>
<p>A variable pattern $x$ is a simple identifier which starts with a
lower case letter.  It matches any value, and binds the variable name
to that value.  The type of $x$ is the expected type of the pattern as
given from outside.  A special case is the wild-card pattern $_$
which is treated as if it was a fresh variable on each occurrence.</p>
<h3 id="typed-patterns">Typed Patterns</h3>
<pre><code class="lang-ebnf">  Pattern1        ::=  varid `:&#39; TypePat
                    |  `_&#39; `:&#39; TypePat
</code></pre>
<p>A typed pattern $x: T$ consists of a pattern variable $x$ and a
type pattern $T$.  The type of $x$ is the type pattern $T$, where 
each type variable and wildcard is replaced by a fresh, unknown type.
This pattern matches any value matched by the <a href="#type-patterns">type pattern</a> 
$T$; it binds the variable name to
that value.  </p>
<h3 id="pattern-binders">Pattern Binders</h3>
<pre><code class="lang-ebnf">  Pattern2        ::=  varid `@&#39; Pattern3
</code></pre>
<p>A pattern binder <code>$x$@$p$</code> consists of a pattern variable $x$ and a 
pattern $p$. The type of the variable $x$ is the static type $T$ of the pattern $p$.
This pattern matches any value $v$ matched by the pattern $p$, 
provided the run-time type of $v$ is also an instance of $T$, 
and it binds the variable name to that value.</p>
<h3 id="literal-patterns">Literal Patterns</h3>
<pre><code class="lang-ebnf">  SimplePattern   ::=  Literal
</code></pre>
<p>A literal pattern $L$ matches any value that is equal (in terms of
$==$) to the literal $L$. The type of $L$ must conform to the
expected type of the pattern.</p>
<h3 id="stable-identifier-patterns">Stable Identifier Patterns</h3>
<pre><code class="lang-ebnf">  SimplePattern   ::=  StableId
</code></pre>
<p>A stable identifier pattern is a <a href="03-types.html#paths">stable identifier</a> $r$.
The type of $r$ must conform to the expected
type of the pattern. The pattern matches any value $v$ such that
<code>$r$ == $v$</code> (see <a href="12-the-scala-standard-library.html#root-classes">here</a>).</p>
<p>To resolve the syntactic overlap with a variable pattern, a
stable identifier pattern may not be a simple name starting with a lower-case
letter. However, it is possible to enclose a such a variable name in
backquotes; then it is treated as a stable identifier pattern.</p>
<h6 id="example">Example</h6>
<p>Consider the following function definition:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> f(x: Int, y: Int) = x <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> y =&gt; ...
}
</code></pre>
<p>Here, <code>y</code> is a variable pattern, which matches any value.
If we wanted to turn the pattern into a stable identifier pattern, this
can be achieved as follows:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> f(x: Int, y: Int) = x <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> `y` =&gt; ...
}
</code></pre>
<p>Now, the pattern matches the <code>y</code> parameter of the enclosing function <code>f</code>.
That is, the match succeeds only if the <code>x</code> argument and the <code>y</code>
argument of <code>f</code> are equal.</p>
<h3 id="constructor-patterns">Constructor Patterns</h3>
<pre><code class="lang-ebnf">SimplePattern   ::=  StableId `(&#39; [Patterns] `)
</code></pre>
<p>A constructor pattern is of the form $c(p_1 , \ldots , p_n)$ where $n
\geq 0$. It consists of a stable identifier $c$, followed by element
patterns $p_1 , \ldots , p_n$. The constructor $c$ is a simple or
qualified name which denotes a <a href="05-classes-and-objects.html#case-classes">case class</a>.
If the case class is monomorphic, then it
must conform to the expected type of the pattern, and the formal
parameter types of $x$&#39;s <a href="05-classes-and-objects.html#class-definitions">primary constructor</a>
are taken as the expected types of the element patterns $p_1, \ldots ,
p_n$.  If the case class is polymorphic, then its type parameters are
instantiated so that the instantiation of $c$ conforms to the expected
type of the pattern. The instantiated formal parameter types of $c$&#39;s
primary constructor are then taken as the expected types of the
component patterns $p_1, \ldots , p_n$.  The pattern matches all
objects created from constructor invocations $c(v_1 , \ldots , v_n)$
where each element pattern $p_i$ matches the corresponding value
$v_i$.</p>
<p>A special case arises when $c$&#39;s formal parameter types end in a
repeated parameter. This is further discussed <a href="#pattern-sequences">here</a>.</p>
<h3 id="tuple-patterns">Tuple Patterns</h3>
<pre><code class="lang-ebnf">  SimplePattern   ::=  `(&#39; [Patterns] `)&#39;
</code></pre>
<p>A tuple pattern <code>($p_1 , \ldots , p_n$)</code> is an alias
for the constructor pattern <code>scala.Tuple$n$($p_1 , \ldots , p_n$)</code>, 
where $n \geq 2$. The empty tuple
<code>()</code> is the unique value of type <code>scala.Unit</code>.</p>
<h3 id="extractor-patterns">Extractor Patterns</h3>
<pre><code class="lang-ebnf">  SimplePattern   ::=  StableId `(&#39; [Patterns] `)&#39;
</code></pre>
<p>An extractor pattern $x(p_1 , \ldots , p_n)$ where $n \geq 0$ is of
the same syntactic form as a constructor pattern. However, instead of
a case class, the stable identifier $x$ denotes an object which has a
member method named <code>unapply</code> or <code>unapplySeq</code> that matches
the pattern.</p>
<p>An <code>unapply</code> method in an object $x$ <em>matches</em> the pattern
$x(p_1 , \ldots , p_n)$ if it takes exactly one argument and one of
the following applies:</p>
<ul>
<li>$n=0$ and <code>unapply</code>&#39;s result type is <code>Boolean</code>. In this case
the extractor pattern matches all values $v$ for which 
<code>$x$.unapply($v$)</code> yields <code>true</code>.</li>
<li>$n=1$ and <code>unapply</code>&#39;s result type is <code>Option[$T$]</code>, for some
type $T$.  In this case, the (only) argument pattern $p_1$ is typed in
turn with expected type $T$.  The extractor pattern matches then all
values $v$ for which <code>$x$.unapply($v$)</code> yields a value of form
<code>Some($v_1$)</code>, and $p_1$ matches $v_1$.</li>
<li>$n&gt;1$ and <code>unapply</code>&#39;s result type is 
<code>Option[($T_1 , \ldots , T_n$)]</code>, for some
types $T_1 , \ldots , T_n$.  In this case, the argument patterns $p_1
, \ldots , p_n$ are typed in turn with expected types $T_1 , \ldots ,
T_n$.  The extractor pattern matches then all values $v$ for which
<code>$x$.unapply($v$)</code> yields a value of form
<code>Some(($v_1 , \ldots , v_n$))</code>, and each pattern
$p_i$ matches the corresponding value $v_i$.</li>
</ul>
<p>An <code>unapplySeq</code> method in an object $x$ matches the pattern
$x(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$ if it takes exactly one argument
and its result type is of the form <code>Option[($T_1 , \ldots , T_m$, Seq[S])]</code> (if <code>m = 0</code>, the type <code>Option[Seq[S]]</code> is also accepted).
This case is further discussed <a href="#pattern-sequences">below</a>.</p>
<h6 id="example">Example</h6>
<p>The <code>Predef</code> object contains a definition of an
extractor object <code>Pair</code>:</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Pair</span> {</span>
  <span class="hljs-keyword">def</span> apply[A, B](x: A, y: B) = Tuple2(x, y)
  <span class="hljs-keyword">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}
</code></pre>
<p>This means that the name <code>Pair</code> can be used in place of <code>Tuple2</code> for tuple
formation as well as for deconstruction of tuples in patterns.
Hence, the following is possible:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> x = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> y = x <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> Pair(i, s) =&gt; Pair(s + i, i * i)
}
</code></pre>
<h3 id="pattern-sequences">Pattern Sequences</h3>
<pre><code class="lang-ebnf">SimplePattern ::= StableId `(&#39; [Patterns `,&#39;] [varid `@&#39;] `_&#39; `*&#39; `)&#39;
</code></pre>
<p>A pattern sequence $p_1 , \ldots , p_n$ appears in two contexts.
First, in a constructor pattern $c(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$, where $c$ is a case class which has $m+1$ primary constructor parameters,  ending in a <a href="04-basic-declarations-and-definitions.html#repeated-parameters">repeated parameter</a> of type <code>S*</code>.
Second, in an extractor pattern $x(q_1 , \ldots , q_m, p_1 , \ldots , p_n)$ if the extractor object $x$ does not have an <code>unapply</code> method,
but it does define an <code>unapplySeq</code> method with a result type conforming to <code>Option[(T_1, ... , T_m, Seq[S])]</code> (if <code>m = 0</code>, the type <code>Option[Seq[S]]</code> is also accepted). The expected type for the patterns $p_i$ is $S$.</p>
<p>The last pattern in a pattern sequence may be a <em>sequence wildcard</em> <code>_*</code>. 
Each element pattern $p<em>i$ is type-checked with
$S$ as expected type, unless it is a sequence wildcard. If a final
sequence wildcard is present, the pattern matches all values $v$ that
are sequences which start with elements matching patterns
$p_1 , \ldots , p</em>{n-1}$.  If no final sequence wildcard is given, the
pattern matches all values $v$ that are sequences of
length $n$ which consist of elements matching patterns $p_1 , \ldots ,
p_n$.</p>
<h3 id="infix-operation-patterns">Infix Operation Patterns</h3>
<pre><code class="lang-ebnf">  Pattern3  ::=  SimplePattern {id [nl] SimplePattern}
</code></pre>
<p>An infix operation pattern $p;\mathit{op};q$ is a shorthand for the
constructor or extractor pattern $\mathit{op}(p, q)$.  The precedence and
associativity of operators in patterns is the same as in 
<a href="06-expressions.html#prefix-infix-and-postfix-operations">expressions</a>.</p>
<p>An infix operation pattern $p;\mathit{op};(q_1 , \ldots , q_n)$ is a
shorthand for the constructor or extractor pattern $\mathit{op}(p, q_1
, \ldots , q_n)$.</p>
<h3 id="pattern-alternatives">Pattern Alternatives</h3>
<pre><code class="lang-ebnf">  Pattern   ::=  Pattern1 { `|&#39; Pattern1 }
</code></pre>
<p>A pattern alternative <code>$p_1$ | $\ldots$ | $p_n$</code>
consists of a number of alternative patterns $p_i$. All alternative
patterns are type checked with the expected type of the pattern. They
may no bind variables other than wildcards. The alternative pattern 
matches a value $v$ if at least one its alternatives matches $v$.</p>
<h3 id="xml-patterns">XML Patterns</h3>
<p>XML patterns are treated <a href="10-xml-expressions-and-patterns.html#xml-patterns">here</a>.</p>
<h3 id="regular-expression-patterns">Regular Expression Patterns</h3>
<p>Regular expression patterns have been discontinued in Scala from version 2.0.</p>
<p>Later version of Scala provide a much simplified version of regular
expression patterns that cover most scenarios of non-text sequence
processing.  A <em>sequence pattern</em> is a pattern that stands in a
position where either (1) a pattern of a type <code>T</code> which is
conforming to
<code>Seq[A]</code> for some <code>A</code> is expected, or (2) a case
class constructor that has an iterated formal parameter
<code>A*</code>.  A wildcard star pattern <code>_*</code> in the
rightmost position stands for arbitrary long sequences. It can be
bound to variables using <code>@</code>, as usual, in which case the variable will have the
type <code>Seq[A]</code>.</p>
<h3 id="irrefutable-patterns">Irrefutable Patterns</h3>
<p>A pattern $p$ is <em>irrefutable</em> for a type $T$, if one of the following applies:</p>
<ol>
<li>$p$ is a variable pattern,</li>
<li>$p$ is a typed pattern $x: T&#39;$, and $T &lt;: T&#39;$,</li>
<li>$p$ is a constructor pattern $c(p_1 , \ldots , p_n)$, the type $T$
is an instance of class $c$, the <a href="05-classes-and-objects.html#class-definitions">primary constructor</a>
of type $T$ has argument types $T_1 , \ldots , T_n$, and each $p_i$ is 
irrefutable for $T_i$.</li>
</ol>
<h2 id="type-patterns">Type Patterns</h2>
<pre><code class="lang-ebnf">  TypePat           ::=  Type
</code></pre>
<p>Type patterns consist of types, type variables, and wildcards. 
A type pattern $T$ is of one of the following  forms:</p>
<ul>
<li><p>A reference to a class $C$, $p.C$, or <code>$T$#$C$</code>.  This
type pattern matches any non-null instance of the given class. 
Note that the prefix of the class, if it is given, is relevant for determining
class instances. For instance, the pattern $p.C$ matches only
instances of classes $C$ which were created with the path $p$ as
prefix.</p>
<p>The bottom types <code>scala.Nothing</code> and <code>scala.Null</code> cannot
be used as type patterns, because they would match nothing in any case.  </p>
</li>
<li><p>A singleton type <code>$p$.type</code>. This type pattern matches only the value
denoted by the path $p$ (that is, a pattern match involved a
comparison of the matched value with $p$ using method <code>eq</code> in class
<code>AnyRef</code>).</p>
</li>
<li><p>A compound type pattern <code>$T_1$ with $\ldots$ with $T_n$</code> where each $T_i$ is a
type pattern. This type pattern matches all values that are matched by each of
the type patterns $T_i$.</p>
</li>
<li><p>A parameterized type pattern $T[a<em>1 , \ldots , a_n]$, where the $a_i$
are type variable patterns or wildcards $\</em>$. 
This type pattern matches all values which match $T$ for
some arbitrary instantiation of the type variables and wildcards. The
bounds or alias type of these type variable are determined as
described <a href="#type-parameter-inference-in-patterns">here</a>.</p>
</li>
<li><p>A parameterized type pattern <code>scala.Array$[T_1]$</code>, where
$T_1$ is a type pattern. This type pattern matches any non-null instance
of type <code>scala.Array$[U_1]$</code>, where $U_1$ is a type matched by $T_1$.</p>
</li>
</ul>
<p>Types which are not of one of the forms described above are also 
accepted as type patterns. However, such type patterns will be translated to their
<a href="03-types.html#type-erasure">erasure</a>.  The Scala
compiler will issue an &quot;unchecked&quot; warning for these patterns to
flag the possible loss of type-safety.</p>
<p>A <em>type variable pattern</em> is a simple identifier which starts with
a lower case letter.</p>
<h2 id="type-parameter-inference-in-patterns">Type Parameter Inference in Patterns</h2>
<p>Type parameter inference is the process of finding bounds for the
bound type variables in a typed pattern or constructor
pattern. Inference takes into account the expected type of the
pattern.</p>
<h3 id="type-parameter-inference-for-typed-patterns-">Type parameter inference for typed patterns.</h3>
<p>Assume a typed pattern $p: T&#39;$. Let $T$ result from $T&#39;$ where all wildcards in
$T&#39;$ are renamed to fresh variable names.  Let $a_1 , \ldots , a_n$ be
the type variables in $T$. These type variables are considered bound
in the pattern. Let the expected type of the pattern be $\mathit{pt}$.</p>
<p>Type parameter inference constructs first a set of subtype constraints over
the type variables $a_i$. The initial constraints set $\mathcal{C}_0$ reflects
just the bounds of these type variables. That is, assuming $T$ has
bound type variables $a_1 , \ldots , a_n$ which correspond to class
type parameters $a&#39;_1 , \ldots , a&#39;_n$ with lower bounds $L_1, \ldots , L_n$
and upper bounds $U_1 , \ldots , U_n$, $\mathcal{C}_0$ contains the constraints </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$a_i$</td>
<td>$&lt;:$</td>
<td>$\sigma U_i$</td>
<td>$(i = 1, \ldots , n)$</td>
</tr>
<tr>
<td>$\sigma L_i$</td>
<td>$&lt;:$</td>
<td>$a_i$</td>
<td>$(i = 1 , \ldots , n)$</td>
</tr>
</tbody>
</table>
<p>where $\sigma$ is the substitution $[a&#39;_1 := a_1 , \ldots , a&#39;_n :=
a_n]$.</p>
<p>The set $\mathcal{C}_0$ is then augmented by further subtype constraints. There are two
cases.</p>
<h6 id="case-1">Case 1</h6>
<p>If there exists a substitution $\sigma$ over the type variables $a_i , \ldots , a_n$ such that $\sigma T$ conforms to $\mathit{pt}$, one determines the weakest subtype constraints $\mathcal{C}_1$ over the type variables $a_1, \ldots , a_n$ such that $\mathcal{C}_0 \wedge \mathcal{C}_1$ implies that $T$ conforms to $\mathit{pt}$.</p>
<h6 id="case-2">Case 2</h6>
<p>Otherwise, if $T$ can not be made to conform to $\mathit{pt}$ by
instantiating its type variables, one determines all type variables in
$\mathit{pt}$ which are defined as type parameters of a method enclosing
the pattern. Let the set of such type parameters be $b_1 , \ldots ,
b_m$. Let $\mathcal{C}&#39;_0$ be the subtype constraints reflecting the bounds of the
type variables $b_i$.  If $T$ denotes an instance type of a final
class, let $\mathcal{C}_2$ be the weakest set of subtype constraints over the type
variables $a_1 , \ldots , a_n$ and $b_1 , \ldots , b_m$ such that
$\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2$ implies that $T$ conforms to
$\mathit{pt}$.  If $T$ does not denote an instance type of a final class,
let $\mathcal{C}_2$ be the weakest set of subtype constraints over the type variables
$a_1 , \ldots , a_n$ and $b_1 , \ldots , b_m$ such that $\mathcal{C}_0 \wedge
\mathcal{C}&#39;_0 \wedge \mathcal{C}_2$ implies that it is possible to construct a type
$T&#39;$ which conforms to both $T$ and $\mathit{pt}$. It is a static error if
there is no satisfiable set of constraints $\mathcal{C}_2$ with this property.</p>
<p>The final step consists in choosing type bounds for the type
variables which imply the established constraint system. The process
is different for the two cases above.</p>
<h6 id="case-1">Case 1</h6>
<p>We take $a_i &gt;: L_i &lt;: U_i$ where each $L_i$ is minimal and each $U_i$ is maximal wrt $&lt;:$ such that $a_i &gt;: L_i &lt;: U_i$ for $i = 1, \ldots, n$ implies $\mathcal{C}_0 \wedge \mathcal{C}_1$.</p>
<h6 id="case-2">Case 2</h6>
<p>We take $a_i &gt;: L_i &lt;: U_i$ and $b_i &gt;: L&#39;_i &lt;: U&#39;_i$ where each $L_i$
and $L&#39;_j$ is minimal and each $U_i$ and $U&#39;_j$ is maximal such that
$a_i &gt;: L_i &lt;: U_i$ for $i = 1 , \ldots , n$ and 
$b_j &gt;: L&#39;_j &lt;: U&#39;_j$ for $j = 1 , \ldots , m$
implies $\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2$.</p>
<p>In both cases, local type inference is permitted to limit the
complexity of inferred bounds. Minimality and maximality of types have
to be understood relative to the set of types of acceptable
complexity.</p>
<h4 id="type-parameter-inference-for-constructor-patterns-">Type parameter inference for constructor patterns.</h4>
<p>Assume a constructor pattern $C(p<em>1 , \ldots , p_n)$ where class $C$
has type type parameters $a_1 , \ldots , a_n$.  These type parameters
are inferred in the same way as for the typed pattern
`(</em>: $C[a_1 , \ldots , a_n]$)`.</p>
<h6 id="example">Example</h6>
<p>Consider the program fragment:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> x: Any
x <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> y: List[a] =&gt; ...
}
</code></pre>
<p>Here, the type pattern <code>List[a]</code> is matched against the
expected type <code>Any</code>. The pattern binds the type variable
<code>a</code>.  Since <code>List[a]</code> conforms to <code>Any</code>
for every type argument, there are no constraints on <code>a</code>.
Hence, <code>a</code> is introduced as an abstract type with no
bounds. The scope of <code>a</code> is right-hand side of its case clause.</p>
<p>On the other hand, if <code>x</code> is declared as</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> x: List[List[String]],
</code></pre>
<p>this generates the constraint
<code>List[a] &lt;: List[List[String]]</code>, which simplifies to
<code>a &lt;: List[String]</code>, because <code>List</code> is covariant. Hence,
<code>a</code> is introduced with upper bound
<code>List[String]</code>.</p>
<h6 id="example">Example</h6>
<p>Consider the program fragment:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> x: Any
x <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> y: List[String] =&gt; ...
}
</code></pre>
<p>Scala does not maintain information about type arguments at run-time,
so there is no way to check that <code>x</code> is a list of strings.
Instead, the Scala compiler will <a href="03-types.html#type-erasure">erase</a> the
pattern to <code>List[_]</code>; that is, it will only test whether the
top-level runtime-class of the value <code>x</code> conforms to
<code>List</code>, and the pattern match will succeed if it does.  This
might lead to a class cast exception later on, in the case where the
list <code>x</code> contains elements other than strings.  The Scala
compiler will flag this potential loss of type-safety with an
&quot;unchecked&quot; warning message.</p>
<h6 id="example">Example</h6>
<p>Consider the program fragment</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Term</span>[<span class="hljs-title">A</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span><span class="hljs-params">(val n: Int)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span>[<span class="hljs-title">Int</span>]</span>
<span class="hljs-keyword">def</span> f[B](t: Term[B]): B = t <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> y: Number =&gt; y.n
}
</code></pre>
<p>The expected type of the pattern <code>y: Number</code> is
<code>Term[B]</code>.  The type <code>Number</code> does not conform to
<code>Term[B]</code>; hence Case 2 of the rules above
applies. This means that <code>b</code> is treated as another type
variable for which subtype constraints are inferred. In our case the
applicable constraint is <code>Number &lt;: Term[B]</code>, which
entails <code>B = Int</code>.  Hence, <code>B</code> is treated in
the case clause as an abstract type with lower and upper bound
<code>Int</code>. Therefore, the right hand side of the case clause,
<code>y.n</code>, of type <code>Int</code>, is found to conform to the
function&#39;s declared result type, <code>Number</code>.</p>
<h2 id="pattern-matching-expressions">Pattern Matching Expressions</h2>
<pre><code class="lang-ebnf">  Expr            ::=  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
  CaseClauses     ::=  CaseClause {CaseClause}
  CaseClause      ::=  `case&#39; Pattern [Guard] `=&gt;&#39; Block
</code></pre>
<p>A pattern matching expression</p>
<pre><code class="lang-scala">e <span class="hljs-keyword">match</span> { <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$ }
</code></pre>
<p>consists of a selector expression $e$ and a number $n &gt; 0$ of
cases. Each case consists of a (possibly guarded) pattern $p_i$ and a
block $b_i$. Each $p_i$ might be complemented by a guard
<code>if $e$</code> where $e$ is a boolean expression. 
The scope of the pattern
variables in $p_i$ comprises the pattern&#39;s guard and the corresponding block $b_i$.</p>
<p>Let $T$ be the type of the selector expression $e$ and let $a_1
, \ldots , a_m$ be the type parameters of all methods enclosing 
the pattern matching expression.  For every $a_i$, let $L_i$ be its
lower bound and $U_i$ be its higher bound.  Every pattern $p \in {p_1, , \ldots , p_n}$
can be typed in two ways. First, it is attempted
to type $p$ with $T$ as its expected type. If this fails, $p$ is
instead typed with a modified expected type $T&#39;$ which results from
$T$ by replacing every occurrence of a type parameter $a_i$ by
\mbox{\sl undefined}.  If this second step fails also, a compile-time
error results. If the second step succeeds, let $T_p$ be the type of
pattern $p$ seen as an expression. One then determines minimal bounds
$L&#39;_1 , \ldots , L&#39;_m$ and maximal bounds $U&#39;_1 , \ldots , U&#39;_m$ such
that for all $i$, $L_i &lt;: L&#39;_i$ and $U&#39;_i &lt;: U_i$ and the following
constraint system is satisfied:</p>
<p>$$L_1 &lt;: a_1 &lt;: U_1\;\wedge\;\ldots\;\wedge\;L_m &lt;: a_m &lt;: U_m \ \Rightarrow\ T_p &lt;: T$$</p>
<p>If no such bounds can be found, a compile time error results.  If such
bounds are found, the pattern matching clause starting with $p$ is
then typed under the assumption that each $a_i$ has lower bound $L&#39;_i$
instead of $L_i$ and has upper bound $U&#39;_i$ instead of $U_i$.</p>
<p>The expected type of every block $b_i$ is the expected type of the
whole pattern matching expression.  The type of the pattern matching
expression is then the <a href="03-types.html#weak-conformance">weak least upper bound</a>
of the types of all blocks
$b_i$.</p>
<p>When applying a pattern matching expression to a selector value,
patterns are tried in sequence until one is found which matches the
<a href="#patterns">selector value</a>. Say this case is <code>$case p_i \Rightarrow b_i$</code>.
The result of the whole expression is the result of evaluating $b_i$,
where all pattern variables of $p_i$ are bound to
the corresponding parts of the selector value.  If no matching pattern
is found, a <code>scala.MatchError</code> exception is thrown.</p>
<p>The pattern in a case may also be followed by a guard suffix
<code>if e</code> with a boolean expression $e$.  The guard expression is
evaluated if the preceding pattern in the case matches. If the guard
expression evaluates to <code>true</code>, the pattern match succeeds as
normal. If the guard expression evaluates to <code>false</code>, the pattern
in the case is considered not to match and the search for a matching
pattern continues.</p>
<p>In the interest of efficiency the evaluation of a pattern matching
expression may try patterns in some other order than textual
sequence. This might affect evaluation through
side effects in guards. However, it is guaranteed that a guard
expression is evaluated only if the pattern it guards matches.</p>
<p>If the selector of a pattern match is an instance of a
<a href="05-classes-and-objects.html#modifiers"><code>sealed</code> class</a>,
the compilation of pattern matching can emit warnings which diagnose
that a given set of patterns is not exhaustive, i.e. that there is a
possibility of a <code>MatchError</code> being raised at run-time. </p>
<h3 id="example">Example</h3>
<p>Consider the following definitions of arithmetic terms:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Term</span>[<span class="hljs-title">T</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">case</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lit</span><span class="hljs-params">(x: Int)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span>[<span class="hljs-title">Int</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">case</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Succ</span><span class="hljs-params">(t: Term[Int])</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span>[<span class="hljs-title">Int</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">case</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IsZero</span><span class="hljs-params">(t: Term[Int])</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span>[<span class="hljs-title">Boolean</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">case</span> <span class="hljs-keyword">class</span> <span class="hljs-title">If</span>[<span class="hljs-title">T</span>]<span class="hljs-params">(c: Term[Boolean],
                 t1: Term[T],
                 t2: Term[T])</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span>[<span class="hljs-title">T</span>]</span>
</code></pre>
<p>There are terms to represent numeric literals, incrementation, a zero
test, and a conditional. Every term carries as a type parameter the
type of the expression it representes (either <code>Int</code> or <code>Boolean</code>).</p>
<p>A type-safe evaluator for such terms can be written as follows.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> eval[T](t: Term[T]): T = t <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> Lit(n)        =&gt; n
  <span class="hljs-keyword">case</span> Succ(u)       =&gt; eval(u) + <span class="hljs-number">1</span>
  <span class="hljs-keyword">case</span> IsZero(u)     =&gt; eval(u) == <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> If(c, u1, u2) =&gt; eval(<span class="hljs-keyword">if</span> (eval(c)) u1 <span class="hljs-keyword">else</span> u2)
}
</code></pre>
<p>Note that the evaluator makes crucial use of the fact that type
parameters of enclosing methods can acquire new bounds through pattern
matching.</p>
<p>For instance, the type of the pattern in the second case,
<code>Succ(u)</code>, is <code>Int</code>. It conforms to the selector type
<code>T</code> only if we assume an upper and lower bound of <code>Int</code> for <code>T</code>.
Under the assumption <code>Int &lt;: T &lt;: Int</code> we can also
verify that the type right hand side of the second case, <code>Int</code>
conforms to its expected type, <code>T</code>.</p>
<h2 id="pattern-matching-anonymous-functions">Pattern Matching Anonymous Functions</h2>
<pre><code class="lang-ebnf">  BlockExpr ::= `{&#39; CaseClauses `}&#39;
</code></pre>
<p>An anonymous function can be defined by a sequence of cases </p>
<pre><code class="lang-scala">{ <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$ }
</code></pre>
<p>which appear as an expression without a prior <code>match</code>.  The
expected type of such an expression must in part be defined. It must
be either <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code> for some $k &gt; 0$,
or <code>scala.PartialFunction[$S_1$, $R$]</code>, where the
argument type(s) $S_1 , \ldots , S_k$ must be fully determined, but the result type
$R$ may be undetermined.</p>
<p>If the expected type is <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code>,
the expression is taken to be equivalent to the anonymous function:</p>
<pre><code class="lang-scala">($x_1: S_1 , \ldots , x_k: S_k$) =&gt; ($x_1 , \ldots , x_k$) <span class="hljs-keyword">match</span> { 
  <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$ 
}
</code></pre>
<p>Here, each $x_i$ is a fresh name.
As was shown <a href="06-expressions.html#anonymous-functions">here</a>, this anonymous function is in turn
equivalent to the following instance creation expression, where
 $T$ is the weak least upper bound of the types of all $b_i$.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">new</span> scala.Function$k$[$S_1 , \ldots , S_k$, $T$] {
  <span class="hljs-keyword">def</span> apply($x_1: S_1 , \ldots , x_k: S_k$): $T$ = ($x_1 , \ldots , x_k$) <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$
  }
}
</code></pre>
<p>If the expected type is <code>scala.PartialFunction[$S$, $R$]</code>,
the expression is taken to be equivalent to the following instance creation expression:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">new</span> scala.PartialFunction[$S$, $T$] {
  <span class="hljs-keyword">def</span> apply($x$: $S$): $T$ = x <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$
  }
  <span class="hljs-keyword">def</span> isDefinedAt($x$: $S$): Boolean = {
    <span class="hljs-keyword">case</span> $p_1$ =&gt; <span class="hljs-keyword">true</span> $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">false</span>
  }
}
</code></pre>
<p>Here, $x$ is a fresh name and $T$ is the weak least upper bound of the
types of all $b_i$. The final default case in the <code>isDefinedAt</code>
method is omitted if one of the patterns $p_1 , \ldots , p_n$ is
already a variable or wildcard pattern.</p>
<h6 id="example">Example</h6>
<p>Here is a method which uses a fold-left operation
<code>/:</code> to compute the scalar product of
two vectors:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> scalarProduct(xs: Array[Double], ys: Array[Double]) =
  (<span class="hljs-number">0.0</span> /: (xs zip ys)) {
    <span class="hljs-keyword">case</span> (a, (b, c)) =&gt; a + b * c
  }
</code></pre>
<p>The case clauses in this code are equivalent to the following
anonymous function:</p>
<pre><code class="lang-scala">(x, y) =&gt; (x, y) <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> (a, (b, c)) =&gt; a + b * c
}
</code></pre>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="./07-implicit-parameters-and-views.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./09-top-level-definitions.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
        <link rel="stylesheet" href="gitbook/style.css">
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="gitbook/app.js"></script>
        
    </body>
</html>
