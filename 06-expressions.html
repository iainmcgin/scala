<!DOCTYPE HTML>
<html lang="en-US">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Expressions | The Scala Language Specification 2.11</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="iainmcgin">
        <meta name="description" content="Scala is a Java-like programming language which unifies
object-oriented and functional programming.  It is a pure
object-oriented language in the sense that every value is an
object. Types and behavior of objects are described by
classes. Classes can be composed using mixin composition.  Scala is
designed to work seamlessly with less pure but mainstream
object-oriented languages like Java.">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="./07-implicit-parameters-and-views.html" />
        
        
        <link rel="prev" href="./05-classes-and-objects.html" />
        

        <meta property="og:title" content="Expressions | The Scala Language Specification 2.11">
        <meta property="og:site_name" content="The Scala Language Specification 2.11">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/iainmcgin">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

          <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [['$','$'], ['\\(','\\)']],
              skipTags: ['script', 'noscript', 'style', 'textarea'],
              processEscapes: true
            }
          });
          </script>
          <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

          <!--
          <script type="text/javascript">
            // clear content of H3 nodes that start with "Example:"
            // the content is only there to determine ID of the H3 element (redcarpet doesn't let us set css id)
            $( document ).ready(function(){ $("h3[id*='example']").text("") })
          </script>
          -->
        
    </head>
    <body>
        
    <div class="book" data-github="iainmcgin/scala" data-level="6" data-basepath="." data-revision="1397801841390">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/iainmcgin/scala" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    
    <a href="https://github.com/iainmcgin/scala/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/iainmcgin/scala/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1><a href="./" >The Scala Language Specification 2.11</a></h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/iainmcgin" target="blank">About the author</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/issues" target="blank">Questions and Issues</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/edit/master/06-expressions.md" target="blank">Edit and Contribute</a>
        </li>
        <li class="divider"></li>
        
        <li data-level="0" data-path="index.html">
            <a href="./"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li  data-level="1" data-path="01-lexical-syntax.html">
                
                <a href="./01-lexical-syntax.html">
                    <i class="fa fa-check"></i> <b>1.</b> Lexical Syntax
                </a>
                
                
            </li>
        
            <li  data-level="2" data-path="02-identifiers-names-and-scopes.html">
                
                <a href="./02-identifiers-names-and-scopes.html">
                    <i class="fa fa-check"></i> <b>2.</b> Identifiers, Names &amp; Scopes
                </a>
                
                
            </li>
        
            <li  data-level="3" data-path="03-types.html">
                
                <a href="./03-types.html">
                    <i class="fa fa-check"></i> <b>3.</b> Types
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="04-basic-declarations-and-definitions.html">
                
                <a href="./04-basic-declarations-and-definitions.html">
                    <i class="fa fa-check"></i> <b>4.</b> Basic Declarations &amp; Definitions
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="05-classes-and-objects.html">
                
                <a href="./05-classes-and-objects.html">
                    <i class="fa fa-check"></i> <b>5.</b> Classes and Objects
                </a>
                
                
            </li>
        
            <li  data-level="6" data-path="06-expressions.html">
                
                <a href="./06-expressions.html">
                    <i class="fa fa-check"></i> <b>6.</b> Expressions
                </a>
                
                
            </li>
        
            <li  data-level="7" data-path="07-implicit-parameters-and-views.html">
                
                <a href="./07-implicit-parameters-and-views.html">
                    <i class="fa fa-check"></i> <b>7.</b> Implicit Patterns &amp; Views
                </a>
                
                
            </li>
        
            <li  data-level="8" data-path="08-pattern-matching.html">
                
                <a href="./08-pattern-matching.html">
                    <i class="fa fa-check"></i> <b>8.</b> Pattern Matching
                </a>
                
                
            </li>
        
            <li  data-level="9" data-path="09-top-level-definitions.html">
                
                <a href="./09-top-level-definitions.html">
                    <i class="fa fa-check"></i> <b>9.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="10" data-path="10-xml-expressions-and-patterns.html">
                
                <a href="./10-xml-expressions-and-patterns.html">
                    <i class="fa fa-check"></i> <b>10.</b> XML Expressions &amp; Patterns
                </a>
                
                
            </li>
        
            <li  data-level="11" data-path="11-user-defined-annotations.html">
                
                <a href="./11-user-defined-annotations.html">
                    <i class="fa fa-check"></i> <b>11.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="12" data-path="12-the-scala-standard-library.html">
                
                <a href="./12-the-scala-standard-library.html">
                    <i class="fa fa-check"></i> <b>12.</b> The Scala Standard Library
                </a>
                
                
            </li>
        
            <li  data-level="13" data-path="13-syntax-summary.html">
                
                <a href="./13-syntax-summary.html">
                    <i class="fa fa-check"></i> <b>13.</b> Syntax Summary
                </a>
                
                
            </li>
        
            <li  data-level="14" data-path="14-references.html">
                
                <a href="./14-references.html">
                    <i class="fa fa-check"></i> <b>14.</b> References
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 78.57142857142857%;min-width: 71.42857142857143%;"></div>
    </div>
    <div class="chapters">
    
        <a href="./index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="./01-lexical-syntax.html" title="Lexical Syntax" class="chapter done new-chapter" data-progress="1" style="left: 7.142857142857143%;"></a>
    
        <a href="./10-xml-expressions-and-patterns.html" title="XML Expressions &amp; Patterns" class="chapter done " data-progress="10" style="left: 14.285714285714286%;"></a>
    
        <a href="./11-user-defined-annotations.html" title="Top Level Definitions" class="chapter done " data-progress="11" style="left: 21.428571428571427%;"></a>
    
        <a href="./12-the-scala-standard-library.html" title="The Scala Standard Library" class="chapter done " data-progress="12" style="left: 28.571428571428573%;"></a>
    
        <a href="./13-syntax-summary.html" title="Syntax Summary" class="chapter done " data-progress="13" style="left: 35.714285714285715%;"></a>
    
        <a href="./14-references.html" title="References" class="chapter done " data-progress="14" style="left: 42.857142857142854%;"></a>
    
        <a href="./02-identifiers-names-and-scopes.html" title="Identifiers, Names &amp; Scopes" class="chapter done new-chapter" data-progress="2" style="left: 50%;"></a>
    
        <a href="./03-types.html" title="Types" class="chapter done new-chapter" data-progress="3" style="left: 57.142857142857146%;"></a>
    
        <a href="./04-basic-declarations-and-definitions.html" title="Basic Declarations &amp; Definitions" class="chapter done new-chapter" data-progress="4" style="left: 64.28571428571429%;"></a>
    
        <a href="./05-classes-and-objects.html" title="Classes and Objects" class="chapter done new-chapter" data-progress="5" style="left: 71.42857142857143%;"></a>
    
        <a href="./06-expressions.html" title="Expressions" class="chapter done new-chapter" data-progress="6" style="left: 78.57142857142857%;"></a>
    
        <a href="./07-implicit-parameters-and-views.html" title="Implicit Patterns &amp; Views" class="chapter  new-chapter" data-progress="7" style="left: 85.71428571428571%;"></a>
    
        <a href="./08-pattern-matching.html" title="Pattern Matching" class="chapter  new-chapter" data-progress="8" style="left: 92.85714285714286%;"></a>
    
        <a href="./09-top-level-definitions.html" title="Top Level Definitions" class="chapter  new-chapter" data-progress="9" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_8">
                    
                        <h1 id="6-expressions">6. Expressions</h1>
<pre><code class="lang-ebnf">Expr         ::=  (Bindings | id | `_&#39;) `=&gt;&#39; Expr
               |  Expr1
Expr1        ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] `else&#39; Expr]
               |  `while&#39; `(&#39; Expr `)&#39; {nl} Expr
               |  `try&#39; (`{&#39; Block `}&#39; | Expr) [`catch&#39; `{&#39; CaseClauses `}&#39;] [`finally&#39; Expr]
               |  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;
               |  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) {nl} [`yield&#39;] Expr
               |  `throw&#39; Expr
               |  `return&#39; [Expr]
               |  [SimpleExpr `.&#39;] id `=&#39; Expr
               |  SimpleExpr1 ArgumentExprs `=&#39; Expr
               |  PostfixExpr
               |  PostfixExpr Ascription
               |  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
PostfixExpr  ::=  InfixExpr [id [nl]]
InfixExpr    ::=  PrefixExpr
               |  InfixExpr id [nl] InfixExpr
PrefixExpr   ::=  [`-&#39; | `+&#39; | `~&#39; | `!&#39;] SimpleExpr
SimpleExpr   ::=  `new&#39; (ClassTemplate | TemplateBody)
               |  BlockExpr
               |  SimpleExpr1 [`_&#39;]
SimpleExpr1  ::=  Literal
               |  Path
               |  `_&#39;
               |  `(&#39; [Exprs] `)&#39;
               |  SimpleExpr `.&#39; id s
               |  SimpleExpr TypeArgs
               |  SimpleExpr1 ArgumentExprs
               |  XmlExpr
Exprs        ::=  Expr {`,&#39; Expr}
BlockExpr    ::=  ‘{’ CaseClauses ‘}’
               |  ‘{’ Block ‘}’
Block        ::=  BlockStat {semi BlockStat} [ResultExpr]
ResultExpr   ::=  Expr1
               |  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
Ascription   ::=  `:&#39; InfixType
               |  `:&#39; Annotation {Annotation}
               |  `:&#39; `_&#39; `*&#39;
</code></pre>
<p>Expressions are composed of operators and operands. Expression forms are
discussed subsequently in decreasing order of precedence. </p>
<h2 id="expression-typing">Expression Typing</h2>
<p>The typing of expressions is often relative to some <em>expected type</em>  (which might be undefined). When we write &quot;expression $e$ is expected to conform to type $T$&quot;, we mean:</p>
<ol>
<li>the expected type of $e$ is $T$, and</li>
<li>the type of expression $e$ must conform to $T$.</li>
</ol>
<p>The following skolemization rule is applied universally for every
expression: If the type of an expression would be an existential type
$T$, then the type of the expression is assumed instead to be a
<a href="03-types.html#existential-types">skolemization</a> of $T$.</p>
<p>Skolemization is reversed by type packing. Assume an expression $e$ of
type $T$ and let $t<em>1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n$ be
all the type variables created by skolemization of some part of $e$ which are free in $T$.
Then the _packed type</em> of $e$ is</p>
<pre><code class="lang-scala">$T$ forSome { <span class="hljs-keyword">type</span> $t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1$; $\ldots$; <span class="hljs-keyword">type</span> $t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n$ }.
</code></pre>
<h2 id="literals">Literals</h2>
<pre><code class="lang-ebnf">SimpleExpr    ::=  Literal
</code></pre>
<p>Typing of literals is as described <a href="01-lexical-syntax.html#literals">here</a>; their
evaluation is immediate.</p>
<h2 id="the-_null_-value">The <em>Null</em> Value</h2>
<p>The <code>null</code> value is of type <code>scala.Null</code>, and is thus
compatible with every reference type.  It denotes a reference value
which refers to a special “<code>null</code>” object. This object
implements methods in class <code>scala.AnyRef</code> as follows:</p>
<ul>
<li><code>eq($x\,$)</code> and <code>==($x\,$)</code> return <code>true</code> iff the
argument $x$ is also the &quot;null&quot; object.</li>
<li><code>ne($x\,$)</code> and <code>!=($x\,$)</code> return true iff the 
argument x is not also the &quot;null&quot; object.</li>
<li><code>isInstanceOf[$T\,$]</code> always returns <code>false</code>.</li>
<li><code>asInstanceOf[$T\,$]</code> returns the <a href="04-basic-declarations-and-definitions.html#value-declarations-and-definitions">default value</a> of type $T$.</li>
<li><code>##</code> returns <code>0</code>.</li>
</ul>
<p>A reference to any other member of the &quot;null&quot; object causes a
<code>NullPointerException</code> to be thrown. </p>
<h2 id="designators">Designators</h2>
<pre><code class="lang-ebnf">SimpleExpr  ::=  Path
              |  SimpleExpr `.&#39; id
</code></pre>
<p>A designator refers to a named term. It can be a <em>simple name</em> or
a <em>selection</em>. </p>
<p>A simple name $x$ refers to a value as specified 
<a href="02-identifiers-names-and-scopes.html#identifiers-names-and-scopes">here</a>.
If $x$ is bound by a definition or declaration in an enclosing class
or object $C$, it is taken to be equivalent to the selection
<code>$C$.this.$x$</code> where $C$ is taken to refer to the class containing $x$
even if the type name $C$ is <a href="02-identifiers-names-and-scopes.html#identifiers-names-and-scopes">shadowed</a> at the
occurrence of $x$.</p>
<p>If $r$ is a <a href="03-types.html#paths">stable identifier</a> of type $T$, the selection $r.x$ refers
statically to a term member $m$ of $r$ that is identified in $T$ by
the name $x$. </p>
<!-- There might be several such members, in which
case overloading resolution (\sref{overloading-resolution}) is applied
to pick a unique one.}  -->

<p>For other expressions $e$, $e.x$ is typed as
if it was <code>{ val $y$ = $e$; $y$.$x$ }</code>, for some fresh name
$y$.  </p>
<p>The expected type of a designator&#39;s prefix is always undefined.  The
type of a designator is the type $T$ of the entity it refers to, with
the following exception: The type of a <a href="03-types.html#paths">path</a> $p$
which occurs in a context where a <a href="03-types.html#singleton-types">stable type</a>
is required is the singleton type <code>$p$.type</code>.</p>
<p>The contexts where a stable type is required are those that satisfy
one of the following conditions:</p>
<ol>
<li>The path $p$ occurs as the prefix of a selection and it does not
designate a constant, or</li>
<li>The expected type $\mathit{pt}$ is a stable type, or</li>
<li>The expected type $\mathit{pt}$ is an abstract type with a stable type as lower
bound, and the type $T$ of the entity referred to by $p$ does not
conform to $\mathit{pt}$, or</li>
<li>The path $p$ designates a module.</li>
</ol>
<p>The selection $e.x$ is evaluated by first evaluating the qualifier
expression $e$, which yields an object $r$, say. The selection&#39;s
result is then the member of $r$ that is either defined by $m$ or defined
by a definition overriding $m$. 
If that member has a type which
conforms to <code>scala.NotNull</code>, the member&#39;s value must be initialized
to a value different from <code>null</code>, otherwise a <code>scala.UnitializedError</code>
is thrown.</p>
<h2 id="this-and-super">This and Super</h2>
<pre><code class="lang-ebnf">SimpleExpr  ::=  [id `.&#39;] `this&#39;
              |  [id &#39;.&#39;] `super&#39; [ClassQualifier] `.&#39; id
</code></pre>
<p>The expression <code>this</code> can appear in the statement part of a
template or compound type. It stands for the object being defined by
the innermost template or compound type enclosing the reference. If
this is a compound type, the type of <code>this</code> is that compound type.
If it is a template of a
class or object definition with simple name $C$, the type of this
is the same as the type of <code>$C$.this</code>.</p>
<p>The expression <code>$C$.this</code> is legal in the statement part of an
enclosing class or object definition with simple name $C$. It
stands for the object being defined by the innermost such definition.
If the expression&#39;s expected type is a stable type, or
<code>$C$.this</code> occurs as the prefix of a selection, its type is
<code>$C$.this.type</code>, otherwise it is the self type of class $C$.</p>
<p>A reference <code>super.$m$</code> refers statically to a method or type $m$
in the least proper supertype of the innermost template containing the
reference.  It evaluates to the member $m&#39;$ in the actual supertype of
that template which is equal to $m$ or which overrides $m$.  The
statically referenced member $m$ must be a type or a
method.  <!-- explanation: so that we need not create several fields for overriding vals --></p>
<p>If it is
a method, it must be concrete, or the template
containing the reference must have a member $m&#39;$ which overrides $m$
and which is labeled <code>abstract override</code>.  </p>
<p>A reference <code>$C$.super.$m$</code> refers statically to a method
or type $m$ in the least proper supertype of the innermost enclosing class or
object definition named $C$ which encloses the reference. It evaluates
to the member $m&#39;$ in the actual supertype of that class or object
which is equal to $m$ or which overrides $m$. The
statically referenced member $m$ must be a type or a
method.  If the statically
referenced member $m$ is a method, it must be concrete, or the innermost enclosing
class or object definition named $C$ must have a member $m&#39;$ which
overrides $m$ and which is labeled <code>abstract override</code>.</p>
<p>The <code>super</code> prefix may be followed by a trait qualifier
<code>[$T\,$]</code>, as in <code>$C$.super[$T\,$].$x$</code>. This is
called a <em>static super reference</em>.  In this case, the reference is
to the type or method of $x$ in the parent trait of $C$ whose simple
name is $T$. That member must be uniquely defined. If it is a method,
it must be concrete.</p>
<h3 id="example">Example</h3>
<p>Consider the following class definitions</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> {</span> <span class="hljs-keyword">def</span> x = <span class="hljs-string">"Root"</span> }
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> {</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">def</span> x = <span class="hljs-string">"A"</span> ; <span class="hljs-keyword">def</span> superA = <span class="hljs-keyword">super</span>.x }
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> {</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">def</span> x = <span class="hljs-string">"B"</span> ; <span class="hljs-keyword">def</span> superB = <span class="hljs-keyword">super</span>.x }
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> {</span>
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">def</span> x = <span class="hljs-string">"C"</span> ; <span class="hljs-keyword">def</span> superC = <span class="hljs-keyword">super</span>.x
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">with</span> <span class="hljs-title">B</span> {</span>
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">def</span> x = <span class="hljs-string">"D"</span> ; <span class="hljs-keyword">def</span> superD = <span class="hljs-keyword">super</span>.x
}
</code></pre>
<p>The linearization of class <code>C</code> is <code>{C, B, Root}</code> and
the linearization of class <code>D</code> is <code>{D, B, A, Root}</code>.
Then we have:</p>
<pre><code class="lang-scala">(<span class="hljs-keyword">new</span> A).superA == <span class="hljs-string">"Root"</span>,
                          (<span class="hljs-keyword">new</span> C).superB = <span class="hljs-string">"Root"</span>, (<span class="hljs-keyword">new</span> C).superC = <span class="hljs-string">"B"</span>,
(<span class="hljs-keyword">new</span> D).superA == <span class="hljs-string">"Root"</span>, (<span class="hljs-keyword">new</span> D).superB = <span class="hljs-string">"A"</span>,    (<span class="hljs-keyword">new</span> D).superD = <span class="hljs-string">"B"</span>,
</code></pre>
<p>Note that the <code>superB</code> function returns different results
depending on whether <code>B</code> is mixed in with class <code>Root</code> or <code>A</code>.</p>
<h2 id="function-applications">Function Applications</h2>
<pre><code class="lang-ebnf">SimpleExpr    ::=  SimpleExpr1 ArgumentExprs
ArgumentExprs ::=  `(&#39; [Exprs] `)&#39;
                |  `(&#39; [Exprs `,&#39;] PostfixExpr `:&#39; `_&#39; `*&#39; &#39;)&#39;
                |  [nl] BlockExpr
Exprs         ::=  Expr {`,&#39; Expr}
</code></pre>
<p>An application <code>$f$($e_1 , \ldots , e_m$)</code> applies the
function $f$ to the argument expressions $e_1 , \ldots , e_m$. If $f$
has a method type <code>($p_1$:$T_1 , \ldots , p_n$:$T_n$)$U$</code>, the type of
each argument expression $e_i$ is typed with the
corresponding parameter type $T_i$ as expected type. Let $S_i$ be type
type of argument $e_i$ $(i = 1 , \ldots , m)$. If $f$ is a polymorphic method,
<a href="#local-type-inference">local type inference</a> is used to determine
type arguments for $f$. If $f$ has some value type, the application is taken to
be equivalent to <code>$f$.apply($e_1 , \ldots , e_m$)</code>,
i.e. the application of an <code>apply</code> method defined by $f$.</p>
<p>The function $f$ must be <em>applicable</em> to its arguments $e_1
, \ldots , e_n$ of types $S_1 , \ldots , S_n$.</p>
<p>If $f$ has a method type $(p<em>1:T_1 , \ldots , p_n:T_n)U$
we say that an argument expression $e_i$ is a _named</em> argument if
it has the form $x_i=e&#39;_i$ and $x_i$ is one of the parameter names
$p_1 , \ldots , p_n$. The function $f$ is applicable if all of the following conditions
hold:</p>
<ul>
<li>For every named argument $x_i=e&#39;_i$ the type $S_i$
is compatible with the parameter type $T_j$ whose name $p_j$ matches $x_i$.</li>
<li>For every positional argument $e_i$ the type $S_i$
is compatible with $T_i$.</li>
<li>If the expected type is defined, the result type $U$ is
compatible to it.</li>
</ul>
<p>If $f$ is a polymorphic method it is applicable if 
<a href="#local-type-inference">local type inference</a> can
determine type arguments so that the instantiated method is applicable. If
$f$ has some value type it is applicable if it has a method member named
<code>apply</code> which is applicable.</p>
<p>Evaluation of <code>$f$($e_1 , \ldots , e_n$)</code> usually entails evaluation of
$f$ and $e_1 , \ldots , e_n$ in that order. Each argument expression
is converted to the type of its corresponding formal parameter.  After
that, the application is rewritten to the function&#39;s right hand side,
with actual arguments substituted for formal parameters.  The result
of evaluating the rewritten right-hand side is finally converted to
the function&#39;s declared result type, if one is given.</p>
<p>The case of a formal parameter with a parameterless
method type <code>=&gt;$T$</code> is treated specially. In this case, the
corresponding actual argument expression $e$ is not evaluated before the
application. Instead, every use of the formal parameter on the
right-hand side of the rewrite rule entails a re-evaluation of $e$. 
In other words, the evaluation order for
<code>=&gt;</code>-parameters is <em>call-by-name</em> whereas the evaluation
order for normal parameters is <em>call-by-value</em>.
Furthermore, it is required that $e$&#39;s <a href="#expression-typing">packed type</a>
conforms to the parameter type $T$.
The behavior of by-name parameters is preserved if the application is
transformed into a block due to named or default arguments. In this case,
the local value for that parameter has the form <code>val $y_i$ = () =&gt; $e$</code>
and the argument passed to the function is <code>$y_i$()</code>.</p>
<p>The last argument in an application may be marked as a sequence
argument, e.g. <code>$e$: _*</code>. Such an argument must correspond
to a <a href="04-basic-declarations-and-definitions.html#repeated-parameters">repeated parameter</a> of type
<code>$S$*</code> and it must be the only argument matching this
parameter (i.e. the number of formal parameters and actual arguments
must be the same). Furthermore, the type of $e$ must conform to
<code>scala.Seq[$T$]</code>, for some type $T$ which conforms to
$S$. In this case, the argument list is transformed by replacing the
sequence $e$ with its elements. When the application uses named
arguments, the vararg parameter has to be specified exactly once.</p>
<p>A function application usually allocates a new frame on the program&#39;s
run-time stack. However, if a local function or a final method calls
itself as its last action, the call is executed using the stack-frame
of the caller.</p>
<h6 id="example">Example</h6>
<p>Assume the following function which computes the sum of a
variable number of arguments:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> sum(xs: Int*) = (<span class="hljs-number">0</span> /: xs) ((x, y) =&gt; x + y)
</code></pre>
<p>Then</p>
<pre><code class="lang-scala">sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
sum(List(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>): _*)
</code></pre>
<p>both yield <code>10</code> as result. On the other hand,</p>
<pre><code class="lang-scala">sum(List(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
</code></pre>
<p>would not typecheck.</p>
<h3 id="named-and-default-arguments">Named and Default Arguments</h3>
<p>If an application might uses named arguments $p = e$ or default
arguments, the following conditions must hold.</p>
<ul>
<li>For every named argument $p_i = e_i$ which appears left of a positional argument
in the argument list $e_1 \ldots e_m$, the argument position $i$ coincides with
the position of parameter $p_i$ in the parameter list of the applied function.</li>
<li>The names $x_i$ of all named arguments are pairwise distinct and no named
argument defines a parameter which is already specified by a
positional argument.</li>
<li>Every formal parameter $p_j:T_j$ which is not specified by either a positional
or a named argument has a default argument.</li>
</ul>
<p>If the application uses named or default
arguments the following transformation is applied to convert it into
an application without named or default arguments. </p>
<p>If the function $f$
has the form <code>$p.m$[$\mathit{targs}$]</code> it is transformed into the
block</p>
<pre><code class="lang-scala">{ <span class="hljs-keyword">val</span> q = $p$
  q.$m$[$\mathit{targs}$]
}
</code></pre>
<p>If the function $f$ is itself an application expression the transformation
is applied recursively on $f$. The result of transforming $f$ is a block of
the form</p>
<pre><code class="lang-scala">{ <span class="hljs-keyword">val</span> q = $p$
  <span class="hljs-keyword">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="hljs-keyword">val</span> $x_k$ = expr$_k$
  q.$m$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
}
</code></pre>
<p>where every argument in $(\mathit{args}_1) , \ldots , (\mathit{args}_l)$ is a reference to
one of the values $x_1 , \ldots , x_k$. To integrate the current application
into the block, first a value definition using a fresh name $y_i$ is created
for every argument in $e_1 , \ldots , e_m$, which is initialised to $e_i$ for
positional arguments and to $e&#39;_i$ for named arguments of the form
<code>$x_i=e&#39;_i$</code>. Then, for every parameter which is not specified
by the argument list, a value definition using a fresh name $z_i$ is created,
which is initialized using the method computing the 
<a href="04-basic-declarations-and-definitions.html#function-declarations-and-definitions">default argument</a> of
this parameter.</p>
<p>Let $\mathit{args}$ be a permutation of the generated names $y_i$ and $z_i$ such such
that the position of each name matches the position of its corresponding
parameter in the method type <code>($p_1:T_1 , \ldots , p_n:T_n$)$U$</code>.
The final result of the transformation is a block of the form</p>
<pre><code class="lang-scala">{ <span class="hljs-keyword">val</span> q = $p$
  <span class="hljs-keyword">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="hljs-keyword">val</span> $x_l$ = expr$_k$
  <span class="hljs-keyword">val</span> $y_1$ = $e_1$
  $\ldots$
  <span class="hljs-keyword">val</span> $y_m$ = $e_m$
  <span class="hljs-keyword">val</span> $z_1$ = $q.m\$<span class="hljs-keyword">default</span>\$i[\mathit{targs}](\mathit{args}_1), \ldots ,(\mathit{args}_l)$
  $\ldots$
  <span class="hljs-keyword">val</span> $z_d$ = $q.m\$<span class="hljs-keyword">default</span>\$j[\mathit{targs}](\mathit{args}_1), \ldots ,(\mathit{args}_l)$
  q.$m$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)($\mathit{args}$)
}
</code></pre>
<h2 id="method-values">Method Values</h2>
<pre><code class="lang-ebnf">SimpleExpr    ::=  SimpleExpr1 `_&#39;
</code></pre>
<p>The expression <code>$e$ _</code> is well-formed if $e$ is of method
type or if $e$ is a call-by-name parameter.  If $e$ is a method with
parameters, <code>$e$ _</code> represents $e$ converted to a function
type by <a href="#eta-expansion">eta expansion</a>. If $e$ is a
parameterless method or call-by-name parameter of type 
<code>=&gt;$T$</code>, <code>$e$ _</code> represents the function of type
<code>() =&gt; $T$</code>, which evaluates $e$ when it is applied to the empty
parameterlist <code>()</code>.</p>
<h6 id="example">Example</h6>
<p>The method values in the left column are each equivalent to the <a href="#eta-expansion">eta-expanded expressions</a> on the right.</p>
<table>
<thead>
<tr>
<th>placeholder syntax</th>
<th>eta-expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>math.sin _</code></td>
<td><code>x =&gt; math.sin(x)</code></td>
</tr>
<tr>
<td><code>math.pow _</code></td>
<td><code>(x1, x2) =&gt; math.pow(x1, x2)</code></td>
</tr>
<tr>
<td><code>val vs = 1 to 9; vs.fold _</code></td>
<td><code>(z) =&gt; (op) =&gt; vs.fold(z)(op)</code></td>
</tr>
<tr>
<td><code>(1 to 9).fold(z)_</code></td>
<td><code>{ val eta1 = z; val eta2 = 1 to 9; op =&gt; eta2.fold(eta1)(op) }</code></td>
</tr>
<tr>
<td><code>Some(1).fold(??? : Int)_</code></td>
<td><code>{ val eta1 = () =&gt; ???; val eta2 = Some(1); op =&gt; eta2.fold(eta1())(op) }</code></td>
</tr>
</tbody>
</table>
<p>Note that a space is necessary between a method name and the trailing underscore
because otherwise the underscore would be considered part of the name.</p>
<h2 id="type-applications">Type Applications</h2>
<pre><code class="lang-ebnf">SimpleExpr    ::=  SimpleExpr TypeArgs
</code></pre>
<p>A type application <code>$e$[$T_1 , \ldots , T_n$]</code> instantiates
a polymorphic value $e$ of type 
<code>[$a_1$ &gt;: $L_1$ &lt;: $U_1, \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$S$</code> 
with argument types
<code>$T_1 , \ldots , T_n$</code>.  Every argument type $T_i$ must obey
the corresponding bounds $L_i$ and $U_i$.  That is, for each $i = 1
, \ldots , n$, we must have $\sigma L_i &lt;: T_i &lt;: \sigma
U_i$, where $\sigma$ is the substitution $[a_1 := T_1 , \ldots , a_n
:= T_n]$.  The type of the application is $\sigma S$.</p>
<p>If the function part $e$ is of some value type, the type application
is taken to be equivalent to 
<code>$e$.apply[$T_1 , \ldots ,$ T$_n$]</code>, i.e. the application of an <code>apply</code> method defined by
$e$.</p>
<p>Type applications can be omitted if 
<a href="#local-type-inference">local type inference</a> can infer best type parameters 
for a polymorphic functions from the types of the actual function arguments
and the expected result type.</p>
<h2 id="tuples">Tuples</h2>
<pre><code class="lang-ebnf">SimpleExpr   ::=  `(&#39; [Exprs] `)&#39;
</code></pre>
<p>A tuple expression <code>($e_1 , \ldots , e_n$)</code> is an alias
for the class instance creation 
<code>scala.Tuple$n$($e_1 , \ldots , e_n$)</code>, where $n \geq 2$.<br>The empty tuple
<code>()</code> is the unique value of type <code>scala.Unit</code>.</p>
<h2 id="instance-creation-expressions">Instance Creation Expressions</h2>
<pre><code class="lang-ebnf">SimpleExpr     ::=  `new&#39; (ClassTemplate | TemplateBody)
</code></pre>
<p>A simple instance creation expression is of the form 
<code>new $c$</code> 
where $c$ is a <a href="05-classes-and-objects.html#constructor-invocations">constructor invocation</a>. Let $T$ be
the type of $c$. Then $T$ must
denote a (a type instance of) a non-abstract subclass of
<code>scala.AnyRef</code>. Furthermore, the <em>concrete self type</em> of the
expression must conform to the <a href="05-classes-and-objects.html#templates">self type</a> of the class denoted by
$T$. The concrete self type is normally
$T$, except if the expression <code>new $c$</code> appears as the
right hand side of a value definition</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> $x$: $S$ = <span class="hljs-keyword">new</span> $c$
</code></pre>
<p>(where the type annotation <code>: $S$</code> may be missing).
In the latter case, the concrete self type of the expression is the
compound type <code>$T$ with $x$.type</code>.</p>
<p>The expression is evaluated by creating a fresh
object of type $T$ which is is initialized by evaluating $c$. The
type of the expression is $T$.</p>
<p>A general instance creation expression is of the form 
<code>new $t$</code> for some <a href="05-classes-and-objects.html#templates">class template</a> $t$.
Such an expression is equivalent to the block</p>
<pre><code class="lang-scala">{ <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">a</span>$ <span class="hljs-keyword">extends</span> $<span class="hljs-title">t</span>$; <span class="hljs-title">new</span> $<span class="hljs-title">a</span>$ }</span>
</code></pre>
<p>where $a$ is a fresh name of an <em>anonymous class</em> which is
inaccessible to user programs.</p>
<p>There is also a shorthand form for creating values of structural
types: If <code>{$D$}</code> is a class body, then 
<code>new {$D$}</code> is equivalent to the general instance creation expression
<code>new AnyRef{$D$}</code>.</p>
<h6 id="example">Example</h6>
<p>Consider the following structural instance creation expression:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">new</span> { <span class="hljs-keyword">def</span> getName() = <span class="hljs-string">"aaron"</span> }
</code></pre>
<p>This is a shorthand for the general instance creation expression</p>
<pre><code class="lang-scala"><span class="hljs-keyword">new</span> AnyRef{ <span class="hljs-keyword">def</span> getName() = <span class="hljs-string">"aaron"</span> }
</code></pre>
<p>The latter is in turn a shorthand for the block</p>
<pre><code class="lang-scala">{ <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">anon</span>\$<span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyRef</span>{</span> <span class="hljs-keyword">def</span> getName() = <span class="hljs-string">"aaron"</span> }; <span class="hljs-keyword">new</span> anon\$X }
</code></pre>
<p>where <code>anon\$X</code> is some freshly created name.</p>
<h2 id="blocks">Blocks</h2>
<pre><code class="lang-ebnf">BlockExpr  ::=  ‘{’ CaseClauses ‘}’
             |  ‘{’ Block ‘}’
Block      ::=  BlockStat {semi BlockStat} [ResultExpr]
</code></pre>
<p>A block expression <code>{$s_1$; $\ldots$; $s_n$; $e\,$}</code> is
constructed from a sequence of block statements $s_1 , \ldots , s_n$
and a final expression $e$.  The statement sequence may not contain
two definitions or declarations that bind the same name in the same
namespace.  The final expression can be omitted, in which
case the unit value <code>()</code> is assumed.</p>
<p>The expected type of the final expression $e$ is the expected
type of the block. The expected type of all preceding statements is
undefined.</p>
<p>The type of a block <code>$s_1$; $\ldots$; $s_n$; $e$</code> is
<code>$T$ forSome {$\,Q\,$}</code>, where $T$ is the type of $e$ and $Q$ 
contains <a href="03-types.html#existential-types">existential clauses</a>
for every value or type name which is free in $T$ 
and which is defined locally in one of the statements $s<em>1 , \ldots , s_n$.
We say the existential clause _binds</em> the occurrence of the value or type name.
Specifically, </p>
<ul>
<li>A locally defined type definition  <code>type$\;t = T$</code>
is bound by the existential clause <code>type$\;t &gt;: T &lt;: T$</code>.
It is an error if $t$ carries type parameters. </li>
<li>A locally defined value definition <code>val$\;x: T = e$</code> is
bound by the existential clause <code>val$\;x: T$</code>.</li>
<li>A locally defined class definition <code>class$\;c$ extends$\;t$</code>
is bound by the existential clause <code>type$\;c &lt;: T$</code> where
$T$ is the least class type or refinement type which is a proper
supertype of the type $c$. It is an error if $c$ carries type parameters. </li>
<li>A locally defined object definition <code>object$\;x\;$extends$\;t$</code>
is bound by the existential clause <code>val$\;x: T$</code> where
$T$ is the least class type or refinement type which is a proper supertype of the type 
<code>$x$.type</code>.</li>
</ul>
<p>Evaluation of the block entails evaluation of its
statement sequence, followed by an evaluation of the final expression
$e$, which defines the result of the block.</p>
<h6 id="example">Example</h6>
<p>Assuming a class <code>Ref[T](x: T)</code>, the block</p>
<pre><code class="lang-scala">{ <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> {</span>$\ldots$} ; <span class="hljs-keyword">new</span> Ref(<span class="hljs-keyword">new</span> C) }
</code></pre>
<p>has the type <code>Ref[_1] forSome { type _1 &lt;: B }</code>.
The block</p>
<pre><code class="lang-scala">{ <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> {</span>$\ldots$} ; <span class="hljs-keyword">new</span> C }
</code></pre>
<p>simply has type <code>B</code>, because with the rules <a href="03-types.html#simplification-rules">here</a>
the existentially quantified type
<code>_1 forSome { type _1 &lt;: B }</code> can be simplified to <code>B</code>.</p>
<h2 id="prefix-infix-and-postfix-operations">Prefix, Infix, and Postfix Operations</h2>
<pre><code class="lang-ebnf">PostfixExpr     ::=  InfixExpr [id [nl]]
InfixExpr       ::=  PrefixExpr
                  |  InfixExpr id [nl] InfixExpr
PrefixExpr      ::=  [`-&#39; | `+&#39; | `!&#39; | `~&#39;] SimpleExpr
</code></pre>
<p>Expressions can be constructed from operands and operators. </p>
<h3 id="prefix-operations">Prefix Operations</h3>
<p>A prefix operation $\mathit{op};e$ consists of a prefix operator $\mathit{op}$, which
must be one of the identifiers ‘<code>+</code>’, ‘<code>-</code>’,
‘<code>!</code>’ or ‘<code>~</code>’. The expression $\mathit{op};e$ is
equivalent to the postfix method application
<code>e.unary_$\mathit{op}$</code>.</p>
<!-- TODO: Generalize to arbitrary operators -->

<p>Prefix operators are different from normal function applications in
that their operand expression need not be atomic. For instance, the
input sequence <code>-sin(x)</code> is read as <code>-(sin(x))</code>, whereas the
function application <code>negate sin(x)</code> would be parsed as the
application of the infix operator <code>sin</code> to the operands
<code>negate</code> and <code>(x)</code>.</p>
<h3 id="postfix-operations">Postfix Operations</h3>
<p>A postfix operator can be an arbitrary identifier. The postfix
operation $e;\mathit{op}$ is interpreted as $e.\mathit{op}$. </p>
<h3 id="infix-operations">Infix Operations</h3>
<p>An infix operator can be an arbitrary identifier. Infix operators have
precedence and associativity defined as follows:</p>
<p>The <em>precedence</em> of an infix operator is determined by the operator&#39;s first
character. Characters are listed below in increasing order of
precedence, with characters on the same line having the same precedence.</p>
<pre><code class="lang-scala">(all letters)
|
^
&amp;
= !
&lt; &gt;
:
+ -
* / %
(all other special characters)
</code></pre>
<p>That is, operators starting with a letter have lowest precedence,
followed by operators starting with <code>`|</code>&#39;, etc.</p>
<p>There&#39;s one exception to this rule, which concerns
<a href="#assignment-operators"><em>assignment operators</em></a>.
The precedence of an assigment operator is the same as the one
of simple assignment <code>(=)</code>. That is, it is lower than the
precedence of any other operator. </p>
<p>The <em>associativity</em> of an operator is determined by the operator&#39;s
last character.  Operators ending in a colon <code>`:</code>&#39; are
right-associative. All other operators are left-associative.</p>
<p>Precedence and associativity of operators determine the grouping of
parts of an expression as follows.</p>
<ul>
<li>If there are several infix operations in an
expression, then operators with higher precedence bind more closely
than operators with lower precedence.</li>
<li>If there are consecutive infix
operations $e_0; \mathit{op}_1; e_1; \mathit{op}_2 \ldots \mathit{op}_n; e_n$ 
with operators $\mathit{op}_1 , \ldots , \mathit{op}_n$ of the same precedence, 
then all these operators must
have the same associativity. If all operators are left-associative,
the sequence is interpreted as
$(\ldots(e_0;\mathit{op}_1;e_1);\mathit{op}_2\ldots);\mathit{op}_n;e_n$. 
Otherwise, if all operators are right-associative, the
sequence is interpreted as
$e_0;\mathit{op}_1;(e_1;\mathit{op}_2;(\ldots \mathit{op}_n;e_n)\ldots)$.</li>
<li>Postfix operators always have lower precedence than infix
operators. E.g. $e_1;\mathit{op}_1;e_2;\mathit{op}_2$ is always equivalent to
$(e_1;\mathit{op}_1;e_2);\mathit{op}_2$.</li>
</ul>
<p>The right-hand operand of a left-associative operator may consist of
several arguments enclosed in parentheses, e.g. $e;\mathit{op};(e_1,\ldots,e_n)$.
This expression is then interpreted as $e.\mathit{op}(e_1,\ldots,e_n)$.</p>
<p>A left-associative binary
operation $e_1;\mathit{op};e_2$ is interpreted as $e_1.\mathit{op}(e_2)$. If $\mathit{op}$ is
right-associative, the same operation is interpreted as
<code>{ val $x$=$e_1$; $e_2$.$\mathit{op}$($x\,$) }</code>, where $x$ is a fresh
name. </p>
<h3 id="assignment-operators">Assignment Operators</h3>
<p>An assignment operator is an operator symbol (syntax category
<code>op</code> in <a href="01-lexical-syntax.html#identifiers">Identifiers</a>) that ends in an equals character
“<code>=</code>”, with the exception of operators for which one of 
the following conditions holds:</p>
<ol>
<li>the operator also starts with an equals character, or</li>
<li>the operator is one of <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(!=)</code>.</li>
</ol>
<p>Assignment operators are treated specially in that they
can be expanded to assignments if no other interpretation is valid.</p>
<p>Let&#39;s consider an assignment operator such as <code>+=</code> in an infix
operation <code>$l$ += $r$</code>, where $l$, $r$ are expressions.<br>This operation can be re-interpreted as an operation which corresponds 
to the assignment</p>
<pre><code class="lang-scala">$l$ = $l$ + $r$
</code></pre>
<p>except that the operation&#39;s left-hand-side $l$ is evaluated only once.</p>
<p>The re-interpretation occurs if the following two conditions are fulfilled.</p>
<ol>
<li>The left-hand-side $l$ does not have a member named
<code>+=</code>, and also cannot be converted by an 
<a href="#implicit-conversions">implicit conversion</a>
to a value with a member named <code>+=</code>.</li>
<li>The assignment <code>$l$ = $l$ + $r$</code> is type-correct.
In particular this implies that $l$ refers to a variable or object 
that can be assigned to, and that is convertible to a value with a member 
named <code>+</code>.</li>
</ol>
<h2 id="typed-expressions">Typed Expressions</h2>
<pre><code class="lang-ebnf">Expr1              ::=  PostfixExpr `:&#39; CompoundType
</code></pre>
<p>The typed expression $e: T$ has type $T$. The type of
expression $e$ is expected to conform to $T$. The result of
the expression is the value of $e$ converted to type $T$.</p>
<h6 id="example">Example</h6>
<p>Here are examples of well-typed and ill-typed expressions.</p>
<pre><code class="lang-scala"><span class="hljs-number">1</span>: Int               <span class="hljs-comment">// legal, of type Int</span>
<span class="hljs-number">1</span>: Long              <span class="hljs-comment">// legal, of type Long</span>
<span class="hljs-comment">// 1: string         // ***** illegal</span>
</code></pre>
<h2 id="annotated-expressions">Annotated Expressions</h2>
<pre><code class="lang-ebnf">Expr1              ::=  PostfixExpr `:&#39; Annotation {Annotation}
</code></pre>
<p>An annotated expression <code>$e$: @$a_1$ $\ldots$ @$a_n$</code>
attaches <a href="11-user-defined-annotations.html#user-defined-annotations">annotations</a> $a_1 , \ldots , a_n$ to the
expression $e$.</p>
<h2 id="assignments">Assignments</h2>
<pre><code class="lang-ebnf">Expr1        ::=  [SimpleExpr `.&#39;] id `=&#39; Expr
               |  SimpleExpr1 ArgumentExprs `=&#39; Expr
</code></pre>
<p>The interpretation of an assignment to a simple variable <code>$x$ = $e$</code>
depends on the definition of $x$. If $x$ denotes a mutable
variable, then the assignment changes the current value of $x$ to be
the result of evaluating the expression $e$. The type of $e$ is
expected to conform to the type of $x$. If $x$ is a parameterless
function defined in some template, and the same template contains a
setter function <code>$x$_=</code> as member, then the assignment
<code>$x$ = $e$</code> is interpreted as the invocation
<code>$x$_=($e\,$)</code> of that setter function.  Analogously, an
assignment <code>$f.x$ = $e$</code> to a parameterless function $x$
is interpreted as the invocation <code>$f.x$_=($e\,$)</code>.</p>
<p>An assignment <code>$f$($\mathit{args}\,$) = $e$</code> with a function application to the
left of the ‘<code>=</code>’ operator is interpreted as 
<code>$f.$update($\mathit{args}$, $e\,$)</code>, i.e.
the invocation of an <code>update</code> function defined by $f$.</p>
<h6 id="example">Example</h6>
<p>Here are some assignment expressions and their equivalent expansions.</p>
<hr>
<p><code>x.f = e</code>             x.f_=(e)
<code>x.f() = e</code>           x.f.update(e)
<code>x.f(i) = e</code>          x.f.update(i, e)
<code>x.f(i, j) = e</code>       x.f.update(i, j, e)</p>
<hr>
<h3 id="example">Example</h3>
<p>Here is the usual imperative code for matrix multiplication.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="hljs-keyword">val</span> zss: Array[Array[Double]] = <span class="hljs-keyword">new</span> Array(xss.length, yss(<span class="hljs-number">0</span>).length)
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (i &lt; xss.length) {
    <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (j &lt; yss(<span class="hljs-number">0</span>).length) {
      <span class="hljs-keyword">var</span> acc = <span class="hljs-number">0.0</span>
      <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>
      <span class="hljs-keyword">while</span> (k &lt; yss.length) {
        acc = acc + xss(i)(k) * yss(k)(j)
        k += <span class="hljs-number">1</span>
      }
      zss(i)(j) = acc
      j += <span class="hljs-number">1</span>
    }
    i += <span class="hljs-number">1</span>
  }
  zss
}
</code></pre>
<p>Desugaring the array accesses and assignments yields the following
expanded version:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="hljs-keyword">val</span> zss: Array[Array[Double]] = <span class="hljs-keyword">new</span> Array(xss.length, yss.apply(<span class="hljs-number">0</span>).length)
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (i &lt; xss.length) {
    <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (j &lt; yss.apply(<span class="hljs-number">0</span>).length) {
      <span class="hljs-keyword">var</span> acc = <span class="hljs-number">0.0</span>
      <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>
      <span class="hljs-keyword">while</span> (k &lt; yss.length) {
        acc = acc + xss.apply(i).apply(k) * yss.apply(k).apply(j)
        k += <span class="hljs-number">1</span>
      }
      zss.apply(i).update(j, acc)
      j += <span class="hljs-number">1</span>
    }
    i += <span class="hljs-number">1</span>
  }
  zss
}
</code></pre>
<h2 id="conditional-expressions">Conditional Expressions</h2>
<pre><code class="lang-ebnf">Expr1          ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] `else&#39; Expr]
</code></pre>
<p>The conditional expression <code>if ($e_1$) $e_2$ else $e_3$</code> chooses
one of the values of $e_2$ and $e_3$, depending on the
value of $e_1$. The condition $e_1$ is expected to
conform to type <code>Boolean</code>.  The then-part $e_2$ and the
else-part $e_3$ are both expected to conform to the expected
type of the conditional expression. The type of the conditional
expression is the <a href="03-types.html#weak-conformance">weak least upper bound</a>
of the types of $e_2$ and
$e_3$.  A semicolon preceding the <code>else</code> symbol of a
conditional expression is ignored.</p>
<p>The conditional expression is evaluated by evaluating first
$e_1$. If this evaluates to <code>true</code>, the result of
evaluating $e_2$ is returned, otherwise the result of
evaluating $e_3$ is returned.</p>
<p>A short form of the conditional expression eliminates the
else-part. The conditional expression <code>if ($e_1$) $e_2$</code> is
evaluated as if it was <code>if ($e_1$) $e_2$ else ()</code>.  </p>
<h2 id="while-loop-expressions">While Loop Expressions</h2>
<pre><code class="lang-ebnf">Expr1          ::=  `while&#39; `(&#39; Expr &#39;)&#39; {nl} Expr
</code></pre>
<p>The while loop expression <code>while ($e_1$) $e_2$</code> is typed and
evaluated as if it was an application of <code>whileLoop ($e_1$) ($e_2$)</code> where
the hypothetical function <code>whileLoop</code> is defined as follows.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> whileLoop(cond: =&gt; Boolean)(body: =&gt; Unit): Unit  =
  <span class="hljs-keyword">if</span> (cond) { body ; whileLoop(cond)(body) } <span class="hljs-keyword">else</span> {}
</code></pre>
<h2 id="do-loop-expressions">Do Loop Expressions</h2>
<pre><code class="lang-ebnf">Expr1          ::=  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;
</code></pre>
<p>The do loop expression <code>do $e_1$ while ($e_2$)</code> is typed and
evaluated as if it was the expression <code>($e_1$ ; while ($e_2$) $e_1$)</code>.
A semicolon preceding the <code>while</code> symbol of a do loop expression is ignored.</p>
<h2 id="for-comprehensions-and-for-loops">For Comprehensions and For Loops</h2>
<pre><code class="lang-ebnf">Expr1          ::=  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) 
                       {nl} [`yield&#39;] Expr
Enumerators    ::=  Generator {semi Generator}
Generator      ::=  Pattern1 `&lt;-&#39; Expr {[semi] Guard | semi Pattern1 `=&#39; Expr}
Guard          ::=  `if&#39; PostfixExpr
</code></pre>
<p>A for loop <code>for ($\mathit{enums}\,$) $e$</code> executes expression $e$
for each binding generated by the enumerators $\mathit{enums}$.  A for
comprehension <code>for ($\mathit{enums}\,$) yield $e$</code> evaluates
expression $e$ for each binding generated by the enumerators $\mathit{enums}$
and collects the results. An enumerator sequence always starts with a
generator; this can be followed by further generators, value
definitions, or guards.  A <em>generator</em> <code>$p$ &lt;- $e$</code>
produces bindings from an expression $e$ which is matched in some way
against pattern $p$. A <em>value definition</em> <code>$p$ = $e$</code> 
binds the value name $p$ (or several names in a pattern $p$) to
the result of evaluating the expression $e$.  A <em>guard</em>
<code>if $e$</code> contains a boolean expression which restricts
enumerated bindings. The precise meaning of generators and guards is
defined by translation to invocations of four methods: <code>map</code>,
<code>withFilter</code>, <code>flatMap</code>, and <code>foreach</code>. These methods can
be implemented in different ways for different carrier types.</p>
<p>The translation scheme is as follows.  In a first step, every
generator <code>$p$ &lt;- $e$</code>, where $p$ is not <a href="08-pattern-matching.html#patterns">irrefutable</a>
for the type of $e$ is replaced by</p>
<pre><code class="lang-scala">$p$ &lt;- $e$.withFilter { <span class="hljs-keyword">case</span> $p$ =&gt; <span class="hljs-keyword">true</span>; <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">false</span> }
</code></pre>
<p>Then, the following rules are applied repeatedly until all
comprehensions have been eliminated.</p>
<ul>
<li>A for comprehension 
<code>for ($p$ &lt;- $e\,$) yield $e&#39;$</code> 
is translated to
<code>$e$.map { case $p$ =&gt; $e&#39;$ }</code>.</li>
<li>A for loop
<code>for ($p$ &lt;- $e\,$) $e&#39;$</code> 
is translated to
<code>$e$.foreach { case $p$ =&gt; $e&#39;$ }</code>.</li>
<li><p>A for comprehension</p>
<pre><code>for ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) yield $e&#39;&#39;$
</code></pre><p>where <code>$\ldots$</code> is a (possibly empty)
sequence of generators, definitions, or guards,
is translated to</p>
<pre><code>$e$.flatMap { case $p$ =&gt; for ($p&#39;$ &lt;- $e&#39;; \ldots$) yield $e&#39;&#39;$ }
</code></pre></li>
<li><p>A for loop</p>
<pre><code>for ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$
</code></pre><p>where <code>$\ldots$</code> is a (possibly empty)
sequence of generators, definitions, or guards,
is translated to</p>
<pre><code>$e$.foreach { case $p$ =&gt; for ($p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$ }
</code></pre></li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a guard
<code>if $g$</code> is translated to a single generator 
<code>$p$ &lt;- $e$.withFilter(($x_1 , \ldots , x_n$) =&gt; $g\,$)</code> where
$x_1 , \ldots , x_n$ are the free variables of $p$.</p>
</li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a value definition 
<code>$p&#39;$ = $e&#39;$</code> is translated to the following generator of pairs of values, where
$x$ and $x&#39;$ are fresh names:</p>
<pre><code>($p$, $p&#39;$) &lt;- for ($x @ p$ &lt;- $e$) yield { val $x&#39; @ p&#39;$ = $e&#39;$; ($x$, $x&#39;$) }
</code></pre></li>
</ul>
<h6 id="example">Example</h6>
<p>The following code produces all pairs of numbers between $1$ and $n-1$
whose sums are prime.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">for</span>  { i &lt;- <span class="hljs-number">1</span> until n
       j &lt;- <span class="hljs-number">1</span> until i
       <span class="hljs-keyword">if</span> isPrime(i+j)
} <span class="hljs-keyword">yield</span> (i, j)
</code></pre>
<p>The for comprehension is translated to:</p>
<pre><code class="lang-scala">(<span class="hljs-number">1</span> until n)
  .flatMap {
     <span class="hljs-keyword">case</span> i =&gt; (<span class="hljs-number">1</span> until i)
       .withFilter { j =&gt; isPrime(i+j) }
       .map { <span class="hljs-keyword">case</span> j =&gt; (i, j) } }
</code></pre>
<h6 id="example">Example</h6>
<p>For comprehensions can be used to express vector
and matrix algorithms concisely.
For instance, here is a function to compute the transpose of a given matrix:</p>
<!-- see test/files/run/t0421.scala -->

<pre><code class="lang-scala"><span class="hljs-keyword">def</span> transpose[A](xss: Array[Array[A]]) = {
  <span class="hljs-keyword">for</span> (i &lt;- Array.range(<span class="hljs-number">0</span>, xss(<span class="hljs-number">0</span>).length)) <span class="hljs-keyword">yield</span>
    <span class="hljs-keyword">for</span> (xs &lt;- xss) <span class="hljs-keyword">yield</span> xs(i)
}
</code></pre>
<p>Here is a function to compute the scalar product of two vectors:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> scalprod(xs: Array[Double], ys: Array[Double]) = {
  <span class="hljs-keyword">var</span> acc = <span class="hljs-number">0.0</span>
  <span class="hljs-keyword">for</span> ((x, y) &lt;- xs zip ys) acc = acc + x * y
  acc
}
</code></pre>
<p>Finally, here is a function to compute the product of two matrices.
Compare with the <a href="#example-imperative-matrix-multiplication">imperative version</a>.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="hljs-keyword">val</span> ysst = transpose(yss)
  <span class="hljs-keyword">for</span> (xs &lt;- xss) <span class="hljs-keyword">yield</span>
    <span class="hljs-keyword">for</span> (yst &lt;- ysst) <span class="hljs-keyword">yield</span>
      scalprod(xs, yst)
}
</code></pre>
<p>The code above makes use of the fact that <code>map</code>, <code>flatMap</code>,
<code>withFilter</code>, and <code>foreach</code> are defined for instances of class
<code>scala.Array</code>.</p>
<h2 id="return-expressions">Return Expressions</h2>
<pre><code class="lang-ebnf">Expr1      ::=  `return&#39; [Expr]
</code></pre>
<p>A return expression <code>return $e$</code> must occur inside the body of some
enclosing named method or function. The innermost enclosing named
method or function in a source program, $f$, must have an explicitly declared result type,
and the type of $e$ must conform to it.<br>The return expression
evaluates the expression $e$ and returns its value as the result of
$f$. The evaluation of any statements or
expressions following the return expression is omitted. The type of 
a return expression is <code>scala.Nothing</code>.</p>
<p>The expression $e$ may be omitted.  The return expression
<code>return</code> is type-checked and evaluated as if it was <code>return ()</code>.</p>
<p>An <code>apply</code> method which is generated by the compiler as an
expansion of an anonymous function does not count as a named function
in the source program, and therefore is never the target of a return
expression.</p>
<p>Returning from a nested anonymous function is implemented by throwing
and catching a <code>scala.runtime.NonLocalReturnException</code>.  Any
exception catches between the point of return and the enclosing
methods might see the exception.  A key comparison makes sure that
these exceptions are only caught by the method instance which is
terminated by the return.</p>
<p>If the return expression is itself part of an anonymous function, it
is possible that the enclosing instance of $f$ has already returned
before the return expression is executed. In that case, the thrown
<code>scala.runtime.NonLocalReturnException</code> will not be caught,
and will propagate up the call stack.</p>
<h2 id="throw-expressions">Throw Expressions</h2>
<pre><code class="lang-ebnf">Expr1      ::=  `throw&#39; Expr
</code></pre>
<p>A throw expression <code>throw $e$</code> evaluates the expression
$e$. The type of this expression must conform to
<code>Throwable</code>.  If $e$ evaluates to an exception
reference, evaluation is aborted with the thrown exception. If $e$
evaluates to <code>null</code>, evaluation is instead aborted with a
<code>NullPointerException</code>. If there is an active
<a href="#try-expressions"><code>try</code> expression</a> which handles the thrown
exception, evaluation resumes with the handler; otherwise the thread
executing the <code>throw</code> is aborted.  The type of a throw expression
is <code>scala.Nothing</code>.</p>
<h2 id="try-expressions">Try Expressions</h2>
<pre><code class="lang-ebnf">Expr1 ::=  `try&#39; `{&#39; Block `}&#39; [`catch&#39; `{&#39; CaseClauses `}&#39;] 
           [`finally&#39; Expr]
</code></pre>
<p>A try expression is of the form <code>try { $b$ } catch $h$</code>
where the handler $h$ is a 
<a href="#pattern-matching-anonymous-functions">pattern matching anonymous function</a></p>
<pre><code class="lang-scala">{ <span class="hljs-keyword">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="hljs-keyword">case</span> $p_n$ =&gt; $b_n$ }
</code></pre>
<p>This expression is evaluated by evaluating the block
$b$.  If evaluation of $b$ does not cause an exception to be
thrown, the result of $b$ is returned. Otherwise the 
handler $h$ is applied to the thrown exception.<br>If the handler contains a case matching the thrown exception,
the first such case is invoked. If the handler contains
no case matching the thrown exception, the exception is 
re-thrown. </p>
<p>Let $\mathit{pt}$ be the expected type of the try expression.  The block
$b$ is expected to conform to $\mathit{pt}$.  The handler $h$
is expected conform to type
<code>scala.PartialFunction[scala.Throwable, $\mathit{pt}\,$]</code>.  The
type of the try expression is the <a href="03-types.html#weak-conformance">weak least upper bound</a>
of the type of $b$
and the result type of $h$.</p>
<p>A try expression <code>try { $b$ } finally $e$</code> evaluates the block
$b$.  If evaluation of $b$ does not cause an exception to be
thrown, the expression $e$ is evaluated. If an exception is thrown
during evaluation of $e$, the evaluation of the try expression is
aborted with the thrown exception. If no exception is thrown during
evaluation of $e$, the result of $b$ is returned as the
result of the try expression. </p>
<p>If an exception is thrown during evaluation of $b$, the finally block
$e$ is also evaluated. If another exception $e$ is thrown
during evaluation of $e$, evaluation of the try expression is
aborted with the thrown exception. If no exception is thrown during
evaluation of $e$, the original exception thrown in $b$ is
re-thrown once evaluation of $e$ has completed.  The block
$b$ is expected to conform to the expected type of the try
expression. The finally expression $e$ is expected to conform to
type <code>Unit</code>.</p>
<p>A try expression <code>try { $b$ } catch $e_1$ finally $e_2$</code> 
is a shorthand
for  <code>try { try { $b$ } catch $e_1$ } finally $e_2$</code>.</p>
<h2 id="anonymous-functions">Anonymous Functions</h2>
<pre><code class="lang-ebnf">Expr            ::=  (Bindings | [`implicit&#39;] id | `_&#39;) `=&gt;&#39; Expr
ResultExpr      ::=  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
Bindings        ::=  `(&#39; Binding {`,&#39; Binding} `)&#39;
Binding         ::=  (id | `_&#39;) [`:&#39; Type]
</code></pre>
<p>The anonymous function <code>($x_1$: $T_1 , \ldots , x_n$: $T_n$) =&gt; e</code> 
maps parameters $x_i$ of types $T_i$ to a result given
by expression $e$. The scope of each formal parameter
$x_i$ is $e$. Formal parameters must have pairwise distinct names.</p>
<p>If the expected type of the anonymous function is of the form
<code>scala.Function$n$[$S_1 , \ldots , S_n$, $R\,$]</code>, the
expected type of $e$ is $R$ and the type $T_i$ of any of the
parameters $x_i$ can be omitted, in which
case<code>$T_i$ = $S_i$</code> is assumed.
If the expected type of the anonymous function is
some other type, all formal parameter types must be explicitly given,
and the expected type of $e$ is undefined. The type of the anonymous
function
is<code>scala.Function$n$[$S_1 , \ldots , S_n$, $T\,$]</code>,
where $T$ is the <a href="#expression-typing">packed type</a>
of $e$. $T$ must be equivalent to a
type which does not refer to any of the formal parameters $x_i$.</p>
<p>The anonymous function is evaluated as the instance creation expression</p>
<pre><code class="lang-scala"><span class="hljs-keyword">new</span> scala.Function$n$[$T_1 , \ldots , T_n$, $T$] {
  <span class="hljs-keyword">def</span> apply($x_1$: $T_1 , \ldots , x_n$: $T_n$): $T$ = $e$
}
</code></pre>
<p>In the case of a single untyped formal parameter, 
<code>($x\,$) =&gt; $e$</code> 
can be abbreviated to <code>$x$ =&gt; $e$</code>. If an
anonymous function <code>($x$: $T\,$) =&gt; $e$</code> with a single
typed parameter appears as the result expression of a block, it can be
abbreviated to <code>$x$: $T$ =&gt; e</code>.</p>
<p>A formal parameter may also be a wildcard represented by an underscore <code>_</code>. 
In that case, a fresh name for the parameter is chosen arbitrarily.</p>
<p>A named parameter of an anonymous function may be optionally preceded
by an <code>implicit</code> modifier. In that case the parameter is
labeled <a href="07-implicit-parameters-and-views.html#implicit-parameters-and-views"><code>implicit</code></a>; however the
parameter section itself does not count as an implicit parameter
section in the sense defined <a href="07-implicit-parameters-and-views.html#implicit-parameters">here</a>. Hence, arguments to
anonymous functions always have to be given explicitly.</p>
<h6 id="example">Example</h6>
<p>Examples of anonymous functions:</p>
<pre><code class="lang-scala">x =&gt; x                             <span class="hljs-comment">// The identity function</span>

f =&gt; g =&gt; x =&gt; f(g(x))             <span class="hljs-comment">// Curried function composition</span>

(x: Int,y: Int) =&gt; x + y           <span class="hljs-comment">// A summation function</span>

() =&gt; { count += <span class="hljs-number">1</span>; count }        <span class="hljs-comment">// The function which takes an</span>
                                   <span class="hljs-comment">// empty parameter list $()$,</span>
                                   <span class="hljs-comment">// increments a non-local variable</span>
                                   <span class="hljs-comment">// `count' and returns the new value.</span>

_ =&gt; <span class="hljs-number">5</span>                             <span class="hljs-comment">// The function that ignores its argument</span>
                                   <span class="hljs-comment">// and always returns 5.</span>
</code></pre>
<h3 id="placeholder-syntax-for-anonymous-functions">Placeholder Syntax for Anonymous Functions</h3>
<pre><code class="lang-ebnf">SimpleExpr1  ::=  `_&#39;
</code></pre>
<p>An expression (of syntactic category <code>Expr</code>)
may contain embedded underscore symbols <code>_</code> at places where identifiers
are legal. Such an expression represents an anonymous function where subsequent
occurrences of underscores denote successive parameters.</p>
<p>Define an <em>underscore section</em> to be an expression of the form
<code>_:$T$</code> where $T$ is a type, or else of the form <code>_</code>,
provided the underscore does not appear as the expression part of a
type ascription <code>_:$T$</code>.</p>
<p>An expression $e$ of syntactic category <code>Expr</code> <em>binds</em> an underscore section
$u$, if the following two conditions hold: (1) $e$ properly contains $u$, and
(2) there is no other expression of syntactic category <code>Expr</code> 
which is properly contained in $e$ and which itself properly contains $u$.</p>
<p>If an expression $e$ binds underscore sections $u_1 , \ldots , u_n$, in this order, it is equivalent to 
the anonymous function <code>($u&#39;_1$, ... $u&#39;_n$) =&gt; $e&#39;$</code>
where each $u_i&#39;$ results from $u_i$ by replacing the underscore with a fresh identifier and
$e&#39;$ results from $e$ by replacing each underscore section $u_i$ by $u_i&#39;$.</p>
<h6 id="example">Example</h6>
<p>The anonymous functions in the left column use placeholder
syntax. Each of these is equivalent to the anonymous function on its right.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_ + 1</code></td>
<td><code>x =&gt; x + 1</code></td>
</tr>
<tr>
<td><code>_ * _</code></td>
<td><code>(x1, x2) =&gt; x1 * x2</code></td>
</tr>
<tr>
<td><code>(_: Int) * 2</code></td>
<td><code>(x: Int) =&gt; (x: Int) * 2</code></td>
</tr>
<tr>
<td><code>if (_) x else y</code></td>
<td><code>z =&gt; if (z) x else y</code></td>
</tr>
<tr>
<td><code>_.map(f)</code></td>
<td><code>x =&gt; x.map(f)</code></td>
</tr>
<tr>
<td><code>_.map(_ + 1)</code></td>
<td><code>x =&gt; x.map(y =&gt; y + 1)</code></td>
</tr>
</tbody>
</table>
<h2 id="constant-expressions">Constant Expressions</h2>
<p>Constant expressions are expressions that the Scala compiler can evaluate to a constant.
The definition of &quot;constant expression&quot; depends on the platform, but they
include at least the expressions of the following forms:</p>
<ul>
<li>A literal of a value class, such as an integer</li>
<li>A string literal</li>
<li>A class constructed with <a href="12-the-scala-standard-library.html#the-predef-object"><code>Predef.classOf</code></a></li>
<li>An element of an enumeration from the underlying platform</li>
<li>A literal array, of the form
<code>Array$(c_1 , \ldots , c_n)$</code>,
where all of the $c_i$&#39;s are themselves constant expressions</li>
<li>An identifier defined by a 
<a href="04-basic-declarations-and-definitions.html#value-declarations-and-definitions">constant value definition</a>.</li>
</ul>
<h2 id="statements">Statements</h2>
<pre><code class="lang-ebnf">BlockStat    ::=  Import
               |  {Annotation} [‘implicit’ | ‘lazy’] Def
               |  {Annotation} {LocalModifier} TmplDef
               |  Expr1
               |
TemplateStat ::=  Import
               |  {Annotation} {Modifier} Def
               |  {Annotation} {Modifier} Dcl
               |  Expr
               |
</code></pre>
<p>Statements occur as parts of blocks and templates.  A statement can be
an import, a definition or an expression, or it can be empty.
Statements used in the template of a class definition can also be
declarations.  An expression that is used as a statement can have an
arbitrary value type. An expression statement $e$ is evaluated by
evaluating $e$ and discarding the result of the evaluation. </p>
<!-- Generalize to implicit coercion? -->

<p>Block statements may be definitions which bind local names in the
block. The only modifier allowed in all block-local definitions is
<code>implicit</code>. When prefixing a class or object definition,
modifiers <code>abstract</code>, <code>final</code>, and <code>sealed</code> are also
permitted.</p>
<p>Evaluation of a statement sequence entails evaluation of the
statements in the order they are written.</p>
<h2 id="implicit-conversions">Implicit Conversions</h2>
<p>Implicit conversions can be applied to expressions whose type does not
match their expected type, to qualifiers in selections, and to unapplied methods. The
available implicit conversions are given in the next two sub-sections.</p>
<p>We say, a type $T$ is <em>compatible</em> to a type $U$ if $T$ weakly conforms
to $U$ after applying <a href="#eta-expansion">eta-expansion</a> and 
<a href="07-implicit-parameters-and-views.html#views">view applications</a>.</p>
<h3 id="value-conversions">Value Conversions</h3>
<p>The following five implicit conversions can be applied to an
expression $e$ which has some value type $T$ and which is type-checked with
some expected type $\mathit{pt}$.</p>
<h4 id="overloading-resolution">Overloading Resolution</h4>
<p>If an expression denotes several possible members of a class, 
<a href="#overloading-resolution">overloading resolution</a>
is applied to pick a unique member.</p>
<h6 id="type-instantiation">Type Instantiation</h6>
<p>An expression $e$ of polymorphic type</p>
<pre><code class="lang-scala">[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$
</code></pre>
<p>which does not appear as the function part of
a type application is converted to a type instance of $T$
by determining with <a href="#local-type-inference">local type inference</a>
instance types <code>$T_1 , \ldots , T_n$</code> 
for the type variables <code>$a_1 , \ldots , a_n$</code> and
implicitly embedding $e$ in the <a href="#type-applications">type application</a>
<code>$e$[$T_1 , \ldots , T_n$]</code>.</p>
<h6 id="numeric-widening">Numeric Widening</h6>
<p>If $e$ has a primitive number type which <a href="03-types.html#weak-conformance">weakly conforms</a>
to the expected type, it is widened to
the expected type using one of the numeric conversion methods
<code>toShort</code>, <code>toChar</code>, <code>toInt</code>, <code>toLong</code>,
<code>toFloat</code>, <code>toDouble</code> defined <a href="12-the-scala-standard-library.html#numeric-value-types">here</a>.</p>
<h6 id="numeric-literal-narrowing">Numeric Literal Narrowing</h6>
<p>If the expected type is <code>Byte</code>, <code>Short</code> or <code>Char</code>, and
the expression $e$ is an integer literal fitting in the range of that
type, it is converted to the same literal in that type.</p>
<h6 id="value-discarding">Value Discarding</h6>
<p>If $e$ has some value type and the expected type is <code>Unit</code>,
$e$ is converted to the expected type by embedding it in the 
term <code>{ $e$; () }</code>.</p>
<h6 id="view-application">View Application</h6>
<p>If none of the previous conversions applies, and $e$&#39;s type
does not conform to the expected type $\mathit{pt}$, it is attempted to convert
$e$ to the expected type with a <a href="07-implicit-parameters-and-views.html#views">view</a>.</p>
<h6 id="dynamic-member-selection">Dynamic Member Selection</h6>
<p>If none of the previous conversions applies, and $e$ is a prefix
of a selection $e.x$, and $e$&#39;s type conforms to class <code>scala.Dynamic</code>,
then the selection is rewritten according to the rules for 
<a href="#dynamic-member-selection">dynamic member selection</a>.</p>
<h3 id="method-conversions">Method Conversions</h3>
<p>The following four implicit conversions can be applied to methods
which are not applied to some argument list.</p>
<h6 id="evaluation">Evaluation</h6>
<p>A parameterless method $m$ of type <code>=&gt; $T$</code> is always converted to
type $T$ by evaluating the expression to which $m$ is bound.</p>
<h6 id="implicit-application">Implicit Application</h6>
<p>If the method takes only implicit parameters, implicit
arguments are passed following the rules <a href="07-implicit-parameters-and-views.html#implicit-parameters">here</a>.</p>
<h6 id="eta-expansion">Eta Expansion</h6>
<p>Otherwise, if the method is not a constructor,
and the expected type $\mathit{pt}$ is a function type
$(\mathit{Ts}&#39;) \Rightarrow T&#39;$, <a href="#eta-expansion">eta-expansion</a>
is performed on the expression $e$.</p>
<h6 id="empty-application">Empty Application</h6>
<p>Otherwise, if $e$ has method type $()T$, it is implicitly applied to the empty
argument list, yielding $e()$.</p>
<h3 id="overloading-resolution">Overloading Resolution</h3>
<p>If an identifier or selection $e$ references several members of a
class, the context of the reference is used to identify a unique
member.  The way this is done depends on whether or not $e$ is used as
a function. Let $\mathscr{A}$ be the set of members referenced by $e$.</p>
<p>Assume first that $e$ appears as a function in an application, as in
<code>$e$($e_1 , \ldots , e_m$)</code>.  </p>
<p>One first determines the set of functions that is potentially
applicable based on the <em>shape</em> of the arguments.</p>
<p>The shape of an argument expression $e$, written  $\mathit{shape}(e)$, is
a type that is defined as follows:</p>
<ul>
<li>For a function expression <code>($p_1$: $T_1 , \ldots , p_n$: $T_n$) =&gt; $b$</code>:
<code>(Any $, \ldots ,$ Any) =&gt; $\mathit{shape}(b)$</code>, where <code>Any</code> occurs $n$ times
in the argument type.</li>
<li>For a named argument <code>$n$ = $e$</code>: $\mathit{shape}(e)$.</li>
<li>For all other expressions: <code>Nothing</code>.</li>
</ul>
<p>Let $\mathscr{B}$ be the set of alternatives in $\mathscr{A}$ that are 
<a href="#function-applications"><em>applicable</em></a>
to expressions $(e_1 , \ldots , e_n)$ of types
$(\mathit{shape}(e_1) , \ldots , \mathit{shape}(e_n))$.
If there is precisely one
alternative in $\mathscr{B}$, that alternative is chosen.</p>
<p>Otherwise, let $S<em>1 , \ldots , S_m$ be the vector of types obtained by
typing each argument with an undefined expected type.  For every
member $m$ in $\mathscr{B}$ one determines whether it is 
applicable to expressions ($e_1 , \ldots , e_m$) of types $S_1
, \ldots , S_m$.
It is an error if none of the members in $\mathscr{B}$ is applicable. If there is one
single applicable alternative, that alternative is chosen. Otherwise, let $\mathscr{CC}$
be the set of applicable alternatives which don&#39;t employ any default argument
in the application to $e_1 , \ldots , e_m$. It is again an error if $\mathscr{CC}$ is empty.
Otherwise, one chooses the _most specific</em> alternative among the alternatives
in $\mathscr{CC}$, according to the following definition of being &quot;as specific as&quot;, and
&quot;more specific than&quot;:</p>
<!--
question: given
  def f(x: Int)
  val f: { def apply(x: Int) }
  f(1) // the value is chosen in our current implementation
 why?
  - method is as specific as value, because value is applicable to method`s argument types (item 1)
  - value is as specific as method (item 3, any other type is always as specific..)
 so the method is not more specific than the value.
-->

<ul>
<li>A parameterized method $m$ of type <code>($p_1:T_1, \ldots , p_n:T_n$)$U$</code> is <em>as specific as</em> some other
member $m&#39;$ of type $S$ if $m&#39;$ is applicable to arguments
<code>($p_1 , \ldots , p_n\,$)</code> of
types $T_1 , \ldots , T_n$.</li>
<li>A polymorphic method of type
<code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is
as specific as some other member of type $S$ if $T$ is as 
specific as $S$ under the assumption that for
$i = 1 , \ldots , n$ each $a_i$ is an abstract type name
bounded from below by $L_i$ and from above by $U_i$.</li>
<li>A member of any other type is always as specific as a parameterized method
or a polymorphic method.</li>
<li>Given two members of types $T$ and $U$ which are 
neither parameterized nor polymorphic method types, the member of type $T$ is as specific as
the member of type $U$ if the existential dual of $T$ conforms to the existential dual of $U$. 
Here, the existential dual of a polymorphic type 
<code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is
<code>$T$ forSome { type $a_1$ &gt;: $L_1$ &lt;: $U_1$ $, \ldots ,$ type $a_n$ &gt;: $L_n$ &lt;: $U_n$}</code>.
The existential dual of every other type is the type itself.</li>
</ul>
<p>The <em>relative weight</em> of an alternative $A$ over an alternative $B$ is a
number from 0 to 2, defined as the sum of</p>
<ul>
<li>1 if $A$ is as specific as $B$, 0 otherwise, and</li>
<li>1 if $A$ is defined in a class or object which is derived
from the class or object defining $B$, 0 otherwise.</li>
</ul>
<p>A class or object $C$ is <em>derived</em> from a class or object $D$ if one of
the following holds:</p>
<ul>
<li>$C$ is a subclass of $D$, or</li>
<li>$C$ is a companion object of a class derived from $D$, or</li>
<li>$D$ is a companion object of a class from which $C$ is derived.</li>
</ul>
<p>An alternative $A$ is <em>more specific</em> than an alternative $B$ if
the relative weight of $A$ over $B$ is greater than the relative
weight of $B$ over $A$.</p>
<p>It is an error if there is no alternative in $\mathscr{CC}$ which is more
specific than all other alternatives in $\mathscr{CC}$.</p>
<p>Assume next that $e$ appears as a function in a type application, as
in <code>$e$[$\mathit{targs}\,$]</code>. Then all alternatives in
$\mathscr{A}$ which take the same number of type parameters as there are type
arguments in $\mathit{targs}$ are chosen. It is an error if no such alternative exists.
If there are several such alternatives, overloading resolution is
applied again to the whole expression <code>$e$[$\mathit{targs}\,$]</code>.  </p>
<p>Assume finally that $e$ does not appear as a function in either
an application or a type application. If an expected type is given,
let $\mathscr{B}$ be the set of those alternatives in $\mathscr{A}$ which are
<a href="#implicit-conversions">compatible</a> to it. Otherwise, let $\mathscr{B}$ be the same 
as $\mathscr{A}$.
We choose in this case the most specific alternative among all
alternatives in $\mathscr{B}$. It is an error if there is no 
alternative in $\mathscr{B}$ which is more specific than all other
alternatives in $\mathscr{B}$.</p>
<h6 id="example">Example</h6>
<p>Consider the following definitions:</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> {</span>}
<span class="hljs-keyword">def</span> f(x: B, y: B) = $\ldots$
<span class="hljs-keyword">def</span> f(x: A, y: B) = $\ldots$
<span class="hljs-keyword">val</span> a: A
<span class="hljs-keyword">val</span> b: B
</code></pre>
<p>Then the application <code>f(b, b)</code> refers to the first
definition of $f$ whereas the application <code>f(a, a)</code>
refers to the second.  Assume now we add a third overloaded definition</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> f(x: B, y: A) = $\ldots$
</code></pre>
<p>Then the application <code>f(a, a)</code> is rejected for being ambiguous, since
no most specific applicable signature exists.</p>
<h3 id="local-type-inference">Local Type Inference</h3>
<p>Local type inference infers type arguments to be passed to expressions
of polymorphic type. Say $e$ is of type [$a_1$ &gt;: $L_1$ &lt;: $U_1
, \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$ and no explicit type parameters
are given. </p>
<p>Local type inference converts this expression to a type
application <code>$e$[$T_1 , \ldots , T_n$]</code>. The choice of the
type arguments $T_1 , \ldots , T_n$ depends on the context in which
the expression appears and on the expected type $\mathit{pt}$. 
There are three cases.</p>
<h6 id="case-1-selections">Case 1: Selections</h6>
<p>If the expression appears as the prefix of a selection with a name
$x$, then type inference is <em>deferred</em> to the whole expression
$e.x$. That is, if $e.x$ has type $S$, it is now treated as having
type [$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$S$,
and local type inference is applied in turn to infer type arguments 
for $a_1 , \ldots , a_n$, using the context in which $e.x$ appears.</p>
<h6 id="case-2-values">Case 2: Values</h6>
<p>If the expression $e$ appears as a value without being applied to
value arguments, the type arguments are inferred by solving a
constraint system which relates the expression&#39;s type $T$ with the
expected type $\mathit{pt}$. Without loss of generality we can assume that
$T$ is a value type; if it is a method type we apply 
<a href="#eta-expansion">eta-expansion</a> to convert it to a function type. Solving
means finding a substitution $\sigma$ of types $T_i$ for the type
parameters $a_i$ such that</p>
<ul>
<li>None of inferred types $T_i$ is a <a href="03-types.html#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e.
$\sigma L_i &lt;: \sigma a_i$ and $\sigma a_i &lt;: \sigma U_i$ for $i = 1 , \ldots , n$.</li>
<li>The expression&#39;s type conforms to the expected type, i.e.
$\sigma T &lt;: \sigma \mathit{pt}$.</li>
</ul>
<p>It is a compile time error if no such substitution exists.<br>If several substitutions exist, local-type inference will choose for
each type variable $a<em>i$ a minimal or maximal type $T_i$ of the
solution space.  A _maximal</em> type $T<em>i$ will be chosen if the type
parameter $a_i$ appears <a href="04-basic-declarations-and-definitions.html#variance-annotations">contravariantly</a> in the
type $T$ of the expression.  A _minimal</em> type $T<em>i$ will be chosen
in all other situations, i.e. if the variable appears covariantly,
non-variantly or not at all in the type $T$. We call such a substitution
an _optimal solution</em> of the given constraint system for the type $T$.</p>
<h6 id="case-3-methods">Case 3: Methods</h6>
<p>The last case applies if the expression
$e$ appears in an application $e(d<em>1 , \ldots , d_m)$. In that case
$T$ is a method type $(p_1:R_1 , \ldots , p_m:R_m)T&#39;$. Without loss of
generality we can assume that the result type $T&#39;$ is a value type; if
it is a method type we apply <a href="#eta-expansion">eta-expansion</a> to
convert it to a function type.  One computes first the types $S_j$ of
the argument expressions $d_j$, using two alternative schemes.  Each
argument expression $d_j$ is typed first with the expected type $R_j$,
in which the type parameters $a_1 , \ldots , a_n$ are taken as type
constants.  If this fails, the argument $d_j$ is typed instead with an
expected type $R_j&#39;$ which results from $R_j$ by replacing every type
parameter in $a_1 , \ldots , a_n$ with _undefined</em>.</p>
<p>In a second step, type arguments are inferred by solving a constraint
system which relates the method&#39;s type with the expected type
$\mathit{pt}$ and the argument types $S_1 , \ldots , S_m$. Solving the
constraint system means
finding a substitution $\sigma$ of types $T_i$ for the type parameters
$a_i$ such that</p>
<ul>
<li>None of inferred types $T_i$ is a <a href="03-types.html#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e. $\sigma L_i &lt;: \sigma a_i$ and
$\sigma a_i &lt;: \sigma U_i$ for $i = 1 , \ldots , n$.</li>
<li>The method&#39;s result type $T&#39;$ conforms to the expected type, i.e. $\sigma T&#39; &lt;: \sigma \mathit{pt}$.</li>
<li>Each argument type <a href="03-types.html#weak-conformance">weakly conforms</a>
to the corresponding formal parameter
type, i.e. $\sigma S_j &lt;:_w \sigma R_j$ for $j = 1 , \ldots , m$.</li>
</ul>
<p>It is a compile time error if no such substitution exists.  If several
solutions exist, an optimal one for the type $T&#39;$ is chosen.</p>
<p>All or parts of an expected type $\mathit{pt}$ may be undefined. The rules for
<a href="03-types.html#conformance">conformance</a> are extended to this case by adding
the rule that for any type $T$ the following two statements are always
true: $\mathit{undefined} &lt;: T$ and $T &lt;: \mathit{undefined}$</p>
<p>It is possible that no minimal or maximal solution for a type variable
exists, in which case a compile-time error results. Because $&lt;:$ is a
pre-order, it is also possible that a solution set has several optimal
solutions for a type. In that case, a Scala compiler is free to pick
any one of them.</p>
<h6 id="example">Example</h6>
<p>Consider the two methods:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> cons[A](x: A, xs: List[A]): List[A] = x :: xs
<span class="hljs-keyword">def</span> nil[B]: List[B] = Nil
</code></pre>
<p>and the definition</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> xs = cons(<span class="hljs-number">1</span>, nil)
</code></pre>
<p>The application of <code>cons</code> is typed with an undefined expected
type. This application is completed by local type inference to
<code>cons[Int](1, nil)</code>.
Here, one uses the following
reasoning to infer the type argument <code>Int</code> for the type
parameter <code>a</code>:</p>
<p>First, the argument expressions are typed. The first argument <code>1</code>
has type <code>Int</code> whereas the second argument <code>nil</code> is
itself polymorphic. One tries to type-check <code>nil</code> with an
expected type <code>List[a]</code>. This leads to the constraint system</p>
<pre><code class="lang-scala">List[b?] &lt;: List[a]
</code></pre>
<p>where we have labeled <code>b?</code> with a question mark to indicate
that it is a variable in the constraint system.
Because class <code>List</code> is covariant, the optimal
solution of this constraint is</p>
<pre><code class="lang-scala">b = scala.Nothing
</code></pre>
<p>In a second step, one solves the following constraint system for
the type parameter <code>a</code> of <code>cons</code>:</p>
<pre><code class="lang-scala">Int &lt;: a?
List[scala.Nothing] &lt;: List[a?]
List[a?] &lt;: $\mathit{undefined}$
</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre><code class="lang-scala">a = Int
</code></pre>
<p>so <code>Int</code> is the type inferred for <code>a</code>.</p>
<h6 id="example">Example</h6>
<p>Consider now the definition</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> ys = cons(<span class="hljs-string">"abc"</span>, xs)
</code></pre>
<p>where <code>xs</code> is defined of type <code>List[Int]</code> as before.
In this case local type inference proceeds as follows.</p>
<p>First, the argument expressions are typed. The first argument
<code>&quot;abc&quot;</code> has type <code>String</code>. The second argument <code>xs</code> is
first tried to be typed with expected type <code>List[a]</code>. This fails,
as <code>List[Int]</code> is not a subtype of <code>List[a]</code>. Therefore,
the second strategy is tried; <code>xs</code> is now typed with expected type
<code>List[$\mathit{undefined}$]</code>. This succeeds and yields the argument type
<code>List[Int]</code>.</p>
<p>In a second step, one solves the following constraint system for
the type parameter <code>a</code> of <code>cons</code>:</p>
<pre><code class="lang-scala">String &lt;: a?
List[Int] &lt;: List[a?]
List[a?] &lt;: $\mathit{undefined}$
</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre><code class="lang-scala">a = scala.Any
</code></pre>
<p>so <code>scala.Any</code> is the type inferred for <code>a</code>.</p>
<h3 id="eta-expansion">Eta Expansion</h3>
<p><em>Eta-expansion</em> converts an expression of method type to an
equivalent expression of function type. It proceeds in two steps.</p>
<p>First, one identifes the maximal sub-expressions of $e$; let&#39;s
say these are $e_1 , \ldots , e_m$. For each of these, one creates a
fresh name $x_i$. Let $e&#39;$ be the expression resulting from
replacing every maximal subexpression $e_i$ in $e$ by the
corresponding fresh name $x_i$. Second, one creates a fresh name $y_i$
for every argument type $T_i$ of the method ($i = 1 , \ldots ,
n$). The result of eta-conversion is then:</p>
<pre><code class="lang-scala">{ val $x_1$ = $e_1$; 
  $\ldots$ 
  val $x_m$ = $e_m$; 
  ($y_1: T_1 , \ldots , y_n: T_n$) =&gt; $e'$($y_1 , \ldots , y_n$) 
}
</code></pre>
<p>The behavior of <a href="#function-applications">call-by-name parameters</a>
is preserved under eta-expansion: the corresponding actual argument expression,
a sub-expression of parameterless method type, is not evaluated in the expanded block.</p>
<h3 id="dynamic-member-selection">Dynamic Member Selection</h3>
<p>The standard Scala library defines a trait <code>scala.Dynamic</code> which defines a member
\@invokeDynamic@ as follows:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">package</span> scala
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Dynamic</span> {</span>
  <span class="hljs-keyword">def</span> applyDynamic (name: String, args: Any*): Any
  ...
}
</code></pre>
<p>Assume a selection of the form $e.x$ where the type of $e$ conforms to <code>scala.Dynamic</code>.
Further assuming the selection is not followed by any function arguments, such an expression can be rewitten under the conditions given <a href="#implicit-conversions">here</a> to:</p>
<pre><code class="lang-scala">$e$.applyDynamic(<span class="hljs-string">"$x$"</span>)
</code></pre>
<p>If the selection is followed by some arguments, e.g. $e.x(\mathit{args})$, then that expression
is rewritten to</p>
<pre><code class="lang-scala">$e$.applyDynamic(<span class="hljs-string">"$x$"</span>, $\mathit{args}$)
</code></pre>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="./05-classes-and-objects.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./07-implicit-parameters-and-views.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
        <link rel="stylesheet" href="gitbook/style.css">
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="gitbook/app.js"></script>
        
    </body>
</html>
