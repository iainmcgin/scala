<!DOCTYPE HTML>
<html lang="en-US">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Implicit Patterns &amp; Views | The Scala Language Specification 2.11</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="iainmcgin">
        <meta name="description" content="Scala is a Java-like programming language which unifies
object-oriented and functional programming.  It is a pure
object-oriented language in the sense that every value is an
object. Types and behavior of objects are described by
classes. Classes can be composed using mixin composition.  Scala is
designed to work seamlessly with less pure but mainstream
object-oriented languages like Java.">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="./08-pattern-matching.html" />
        
        
        <link rel="prev" href="./06-expressions.html" />
        

        <meta property="og:title" content="Implicit Patterns &amp; Views | The Scala Language Specification 2.11">
        <meta property="og:site_name" content="The Scala Language Specification 2.11">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/iainmcgin">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

          <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [['$','$'], ['\\(','\\)']],
              skipTags: ['script', 'noscript', 'style', 'textarea'],
              processEscapes: true
            }
          });
          </script>
          <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

          <!--
          <script type="text/javascript">
            // clear content of H3 nodes that start with "Example:"
            // the content is only there to determine ID of the H3 element (redcarpet doesn't let us set css id)
            $( document ).ready(function(){ $("h3[id*='example']").text("") })
          </script>
          -->
        
    </head>
    <body>
        
    <div class="book" data-github="iainmcgin/scala" data-level="7" data-basepath="." data-revision="1397801841390">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/iainmcgin/scala" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    
    <a href="https://github.com/iainmcgin/scala/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/iainmcgin/scala/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1><a href="./" >The Scala Language Specification 2.11</a></h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/iainmcgin" target="blank">About the author</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/issues" target="blank">Questions and Issues</a>
        </li>
        <li>
            <a href="https://github.com/iainmcgin/scala/edit/master/07-implicit-parameters-and-views.md" target="blank">Edit and Contribute</a>
        </li>
        <li class="divider"></li>
        
        <li data-level="0" data-path="index.html">
            <a href="./"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li  data-level="1" data-path="01-lexical-syntax.html">
                
                <a href="./01-lexical-syntax.html">
                    <i class="fa fa-check"></i> <b>1.</b> Lexical Syntax
                </a>
                
                
            </li>
        
            <li  data-level="2" data-path="02-identifiers-names-and-scopes.html">
                
                <a href="./02-identifiers-names-and-scopes.html">
                    <i class="fa fa-check"></i> <b>2.</b> Identifiers, Names &amp; Scopes
                </a>
                
                
            </li>
        
            <li  data-level="3" data-path="03-types.html">
                
                <a href="./03-types.html">
                    <i class="fa fa-check"></i> <b>3.</b> Types
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="04-basic-declarations-and-definitions.html">
                
                <a href="./04-basic-declarations-and-definitions.html">
                    <i class="fa fa-check"></i> <b>4.</b> Basic Declarations &amp; Definitions
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="05-classes-and-objects.html">
                
                <a href="./05-classes-and-objects.html">
                    <i class="fa fa-check"></i> <b>5.</b> Classes and Objects
                </a>
                
                
            </li>
        
            <li  data-level="6" data-path="06-expressions.html">
                
                <a href="./06-expressions.html">
                    <i class="fa fa-check"></i> <b>6.</b> Expressions
                </a>
                
                
            </li>
        
            <li  data-level="7" data-path="07-implicit-parameters-and-views.html">
                
                <a href="./07-implicit-parameters-and-views.html">
                    <i class="fa fa-check"></i> <b>7.</b> Implicit Patterns &amp; Views
                </a>
                
                
            </li>
        
            <li  data-level="8" data-path="08-pattern-matching.html">
                
                <a href="./08-pattern-matching.html">
                    <i class="fa fa-check"></i> <b>8.</b> Pattern Matching
                </a>
                
                
            </li>
        
            <li  data-level="9" data-path="09-top-level-definitions.html">
                
                <a href="./09-top-level-definitions.html">
                    <i class="fa fa-check"></i> <b>9.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="10" data-path="10-xml-expressions-and-patterns.html">
                
                <a href="./10-xml-expressions-and-patterns.html">
                    <i class="fa fa-check"></i> <b>10.</b> XML Expressions &amp; Patterns
                </a>
                
                
            </li>
        
            <li  data-level="11" data-path="11-user-defined-annotations.html">
                
                <a href="./11-user-defined-annotations.html">
                    <i class="fa fa-check"></i> <b>11.</b> Top Level Definitions
                </a>
                
                
            </li>
        
            <li  data-level="12" data-path="12-the-scala-standard-library.html">
                
                <a href="./12-the-scala-standard-library.html">
                    <i class="fa fa-check"></i> <b>12.</b> The Scala Standard Library
                </a>
                
                
            </li>
        
            <li  data-level="13" data-path="13-syntax-summary.html">
                
                <a href="./13-syntax-summary.html">
                    <i class="fa fa-check"></i> <b>13.</b> Syntax Summary
                </a>
                
                
            </li>
        
            <li  data-level="14" data-path="14-references.html">
                
                <a href="./14-references.html">
                    <i class="fa fa-check"></i> <b>14.</b> References
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 85.71428571428571%;min-width: 78.57142857142857%;"></div>
    </div>
    <div class="chapters">
    
        <a href="./index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="./01-lexical-syntax.html" title="Lexical Syntax" class="chapter done new-chapter" data-progress="1" style="left: 7.142857142857143%;"></a>
    
        <a href="./10-xml-expressions-and-patterns.html" title="XML Expressions &amp; Patterns" class="chapter done " data-progress="10" style="left: 14.285714285714286%;"></a>
    
        <a href="./11-user-defined-annotations.html" title="Top Level Definitions" class="chapter done " data-progress="11" style="left: 21.428571428571427%;"></a>
    
        <a href="./12-the-scala-standard-library.html" title="The Scala Standard Library" class="chapter done " data-progress="12" style="left: 28.571428571428573%;"></a>
    
        <a href="./13-syntax-summary.html" title="Syntax Summary" class="chapter done " data-progress="13" style="left: 35.714285714285715%;"></a>
    
        <a href="./14-references.html" title="References" class="chapter done " data-progress="14" style="left: 42.857142857142854%;"></a>
    
        <a href="./02-identifiers-names-and-scopes.html" title="Identifiers, Names &amp; Scopes" class="chapter done new-chapter" data-progress="2" style="left: 50%;"></a>
    
        <a href="./03-types.html" title="Types" class="chapter done new-chapter" data-progress="3" style="left: 57.142857142857146%;"></a>
    
        <a href="./04-basic-declarations-and-definitions.html" title="Basic Declarations &amp; Definitions" class="chapter done new-chapter" data-progress="4" style="left: 64.28571428571429%;"></a>
    
        <a href="./05-classes-and-objects.html" title="Classes and Objects" class="chapter done new-chapter" data-progress="5" style="left: 71.42857142857143%;"></a>
    
        <a href="./06-expressions.html" title="Expressions" class="chapter done new-chapter" data-progress="6" style="left: 78.57142857142857%;"></a>
    
        <a href="./07-implicit-parameters-and-views.html" title="Implicit Patterns &amp; Views" class="chapter done new-chapter" data-progress="7" style="left: 85.71428571428571%;"></a>
    
        <a href="./08-pattern-matching.html" title="Pattern Matching" class="chapter  new-chapter" data-progress="8" style="left: 92.85714285714286%;"></a>
    
        <a href="./09-top-level-definitions.html" title="Top Level Definitions" class="chapter  new-chapter" data-progress="9" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_6">
                    
                        <h1 id="7-implicit-parameters-and-views">7. Implicit Parameters and Views</h1>
<h2 id="the-implicit-modifier">The Implicit Modifier</h2>
<pre><code class="lang-ebnf">LocalModifier  ::= ‘implicit’
ParamClauses   ::= {ParamClause} [nl] ‘(’ ‘implicit’ Params ‘)’
</code></pre>
<p>Template members and parameters labeled with an <code>implicit</code>
modifier can be passed to <a href="#implicit-parameters">implicit parameters</a>
and can be used as implicit conversions called <a href="#views">views</a>. 
The <code>implicit</code> modifier is illegal for all
type members, as well as for <a href="09-top-level-definitions.html#packagings">top-level objects</a>.</p>
<h3 id="example">Example</h3>
<p>The following code defines an abstract class of monoids and
two concrete implementations, <code>StringMonoid</code> and
<code>IntMonoid</code>. The two implementations are marked implicit.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monoid</span>[<span class="hljs-title">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">SemiGroup</span>[<span class="hljs-title">A</span>] {</span>
  <span class="hljs-keyword">def</span> unit: A
  <span class="hljs-keyword">def</span> add(x: A, y: A): A
}
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Monoids</span> {</span>
  implicit <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">stringMonoid</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monoid</span>[<span class="hljs-title">String</span>] {</span>
    <span class="hljs-keyword">def</span> add(x: String, y: String): String = x.concat(y)
    <span class="hljs-keyword">def</span> unit: String = <span class="hljs-string">""</span>
  }
  implicit <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">intMonoid</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monoid</span>[<span class="hljs-title">Int</span>] {</span>
    <span class="hljs-keyword">def</span> add(x: Int, y: Int): Int = x + y
    <span class="hljs-keyword">def</span> unit: Int = <span class="hljs-number">0</span>
  }
}
</code></pre>
<h2 id="implicit-parameters">Implicit Parameters</h2>
<p>An implicit parameter list
<code>(implicit $p_1$,$\ldots$,$p_n$)</code> of a method marks the parameters $p_1 , \ldots , p_n$ as
implicit. A method or constructor can have only one implicit parameter
list, and it must be the last parameter list given.</p>
<p>A method with implicit parameters can be applied to arguments just
like a normal method. In this case the <code>implicit</code> label has no
effect. However, if such a method misses arguments for its implicit
parameters, such arguments will be automatically provided.</p>
<p>The actual arguments that are eligible to be passed to an implicit
parameter of type $T$ fall into two categories. First, eligible are
all identifiers $x$ that can be accessed at the point of the method
call without a prefix and that denote an 
<a href="#the-implicit-modifier">implicit definition</a>
or an implicit parameter.  An eligible
identifier may thus be a local name, or a member of an enclosing
template, or it may be have been made accessible without a prefix
through an <a href="04-basic-declarations-and-definitions.html#import-clauses">import clause</a>. If there are no eligible
identifiers under this rule, then, second, eligible are also all
<code>implicit</code> members of some object that belongs to the implicit
scope of the implicit parameter&#39;s type, $T$.</p>
<p>The <em>implicit scope</em> of a type $T$ consists of all <a href="05-classes-and-objects.html#object-definitions">companion modules</a> of classes that are associated with the implicit parameter&#39;s type.
Here, we say a class $C$ is <em>associated</em> with a type $T$ if it is a <a href="05-classes-and-objects.html#class-linearization">base class</a> of some part of $T$.</p>
<p>The <em>parts</em> of a type $T$ are:</p>
<ul>
<li>if $T$ is a compound type <code>$T_1$ with $\ldots$ with $T_n$</code>,
the union of the parts of $T_1 , \ldots , T_n$, as well as $T$ itself;</li>
<li>if $T$ is a parameterized type <code>$S$[$T_1 , \ldots , T_n$]</code>,
the union of the parts of $S$ and $T_1 , \ldots , T_n$;</li>
<li>if $T$ is a singleton type <code>$p$.type</code>,
the parts of the type of $p$;</li>
<li>if $T$ is a type projection <code>$S$#$U$</code>,
the parts of $S$ as well as $T$ itself;</li>
<li>if $T$ is a type alias, the parts of its expansion;</li>
<li>if $T$ is an abstract type, the parts of its upper bound;</li>
<li>if $T$ denotes an implicit conversion to a type with a method with argument types $T_1 , \ldots , T_n$ and result type $U$,
the union of the parts of $T_1 , \ldots , T_n$ and $U$;</li>
<li>the parts of quantified (existential or univeral) and annotated types are defined as the parts of the underlying types (e.g., the parts of <code>T forSome { ... }</code> are the parts of <code>T</code>);</li>
<li>in all other cases, just $T$ itself.</li>
</ul>
<p>Note that packages are internally represented as classes with companion modules to hold the package members.
Thus, implicits defined in a package object are part of the implicit scope of a type prefixed by that package.</p>
<p>If there are several eligible arguments which match the implicit
parameter&#39;s type, a most specific one will be chosen using the rules
of static <a href="06-expressions.html#overloading-resolution">overloading resolution</a>.
If the parameter has a default argument and no implicit argument can
be found the default argument is used.</p>
<h6 id="example">Example</h6>
<p>Assuming the classes from the <a href="#example-monoid"><code>Monoid</code> example</a>, here is a
method which computes the sum of a list of elements using the
monoid&#39;s <code>add</code> and <code>unit</code> operations.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> sum[A](xs: List[A])(implicit m: Monoid[A]): A =
  <span class="hljs-keyword">if</span> (xs.isEmpty) m.unit
  <span class="hljs-keyword">else</span> m.add(xs.head, sum(xs.tail))
</code></pre>
<p>The monoid in question is marked as an implicit parameter, and can therefore
be inferred based on the type of the list.
Consider for instance the call <code>sum(List(1, 2, 3))</code>
in a context where <code>stringMonoid</code> and <code>intMonoid</code>
are visible.  We know that the formal type parameter <code>a</code> of
<code>sum</code> needs to be instantiated to <code>Int</code>. The only
eligible object which matches the implicit formal parameter type
<code>Monoid[Int]</code> is <code>intMonoid</code> so this object will
be passed as implicit parameter.</p>
<p>This discussion also shows that implicit parameters are inferred after
any type arguments are <a href="06-expressions.html#local-type-inference">inferred</a>.</p>
<p>Implicit methods can themselves have implicit parameters. An example
is the following method from module <code>scala.List</code>, which injects
lists into the <code>scala.Ordered</code> class, provided the element
type of the list is also convertible to this type.</p>
<pre><code class="lang-scala">implicit <span class="hljs-keyword">def</span> list2ordered[A](x: List[A])
  (implicit elem2ordered: A =&gt; Ordered[A]): Ordered[List[A]] = 
  ...
</code></pre>
<p>Assume in addition a method</p>
<pre><code class="lang-scala">implicit <span class="hljs-keyword">def</span> int2ordered(x: Int): Ordered[Int]
</code></pre>
<p>that injects integers into the <code>Ordered</code> class.  We can now
define a <code>sort</code> method over ordered lists:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> sort[A](xs: List[A])(implicit a2ordered: A =&gt; Ordered[A]) = ...
</code></pre>
<p>We can apply <code>sort</code> to a list of lists of integers 
<code>yss: List[List[Int]]</code> 
as follows:</p>
<pre><code class="lang-scala">sort(yss)
</code></pre>
<p>The call above will be completed by passing two nested implicit arguments:</p>
<pre><code class="lang-scala">sort(yss)(xs: List[Int] =&gt; list2ordered[Int](xs)(int2ordered)) .
</code></pre>
<p>The possibility of passing implicit arguments to implicit arguments
raises the possibility of an infinite recursion.  For instance, one
might try to define the following method, which injects <em>every</em> type into the 
<code>Ordered</code> class:</p>
<pre><code class="lang-scala">implicit <span class="hljs-keyword">def</span> magic[A](x: A)(implicit a2ordered: A =&gt; Ordered[A]): Ordered[A] = 
  a2ordered(x)
</code></pre>
<p>Now, if one tried to apply
<code>sort</code> to an argument <code>arg</code> of a type that did not have
another injection into the <code>Ordered</code> class, one would obtain an infinite
expansion:</p>
<pre><code class="lang-scala">sort(arg)(x =&gt; magic(x)(x =&gt; magic(x)(x =&gt; ... )))
</code></pre>
<p>To prevent such infinite expansions, the compiler keeps track of 
a stack of “open implicit types” for which implicit arguments are currently being
searched. Whenever an implicit argument for type $T$ is searched, the
“core type” of $T$ is added to the stack. Here, the <em>core type</em>
of $T$ is $T$ with aliases expanded, top-level type <a href="11-user-defined-annotations.html#user-defined-annotations">annotations</a> and
<a href="03-types.html#compound-types">refinements</a> removed, and occurrences
of top-level existentially bound variables replaced by their upper
bounds. The core type is removed from the stack once the search for
the implicit argument either definitely fails or succeeds. Everytime a
core type is added to the stack, it is checked that this type does not
dominate any of the other types in the set.</p>
<p>Here, a core type $T$ <em>dominates</em> a type $U$ if $T$ is 
<a href="03-types.html#type-equivalence">equivalent</a>
to $U$, or if the top-level type constructors of $T$ and $U$ have a
common element and $T$ is more complex than $U$.</p>
<p>The set of <em>top-level type constructors</em> $\mathit{ttcs}(T)$ of a type $T$ depends on the form of
the type:</p>
<ul>
<li>For a type designator,  $\mathit{ttcs}(p.c) ~=~ {c}$;</li>
<li>For a parameterized type,  $\mathit{ttcs}(p.c[\mathit{targs}]) ~=~ {c}$;</li>
<li>For a singleton type,  $\mathit{ttcs}(p.type) ~=~ \mathit{ttcs}(T)$, provided $p$ has type $T$;</li>
<li>For a compound type, <code>$\mathit{ttcs}(T_1$ with $\ldots$ with $T_n)$</code> $~=~ \mathit{ttcs}(T_1) \cup \ldots \cup \mathit{ttcs}(T_n)$.</li>
</ul>
<p>The <em>complexity</em> $\mathit{complexity}(T)$ of a core type is an integer which also depends on the form of
the type:</p>
<ul>
<li>For a type designator, $\mathit{complexity}(p.c) ~=~ 1 + \mathit{complexity}(p)$</li>
<li>For a parameterized type, $\mathit{complexity}(p.c[\mathit{targs}]) ~=~ 1 + \Sigma \mathit{complexity}(\mathit{targs})$</li>
<li>For a singleton type denoting a package $p$, $\mathit{complexity}(p.type) ~=~ 0$</li>
<li>For any other singleton type, $\mathit{complexity}(p.type) ~=~ 1 + \mathit{complexity}(T)$, provided $p$ has type $T$;</li>
<li>For a compound type, <code>$\mathit{complexity}(T_1$ with $\ldots$ with $T_n)$</code> $= \Sigma\mathit{complexity}(T_i)$</li>
</ul>
<h6 id="example">Example</h6>
<p>When typing <code>sort(xs)</code> for some list <code>xs</code> of type <code>List[List[List[Int]]]</code>,
the sequence of types for
which implicit arguments are searched is</p>
<pre><code class="lang-scala">List[List[Int]] =&gt; Ordered[List[List[Int]]],
List[Int] =&gt; Ordered[List[Int]]
Int =&gt; Ordered[Int]
</code></pre>
<p>All types share the common type constructor <code>scala.Function1</code>,
but the complexity of the each new type is lower than the complexity of the previous types.
Hence, the code typechecks.</p>
<h6 id="example">Example</h6>
<p>Let <code>ys</code> be a list of some type which cannot be converted
to <code>Ordered</code>. For instance:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> ys = List(<span class="hljs-keyword">new</span> IllegalArgumentException, <span class="hljs-keyword">new</span> ClassCastException, <span class="hljs-keyword">new</span> Error)
</code></pre>
<p>Assume that the definition of <code>magic</code> above is in scope. Then the sequence
of types for which implicit arguments are searched is</p>
<pre><code class="lang-scala">Throwable =&gt; Ordered[Throwable],
Throwable =&gt; Ordered[Throwable],
...
</code></pre>
<p>Since the second type in the sequence is equal to the first, the compiler
will issue an error signalling a divergent implicit expansion.</p>
<h2 id="views">Views</h2>
<p>Implicit parameters and methods can also define implicit conversions
called views. A <em>view</em> from type $S$ to type $T$ is
defined by an implicit value which has function type
<code>$S$=&gt;$T$</code> or <code>(=&gt;$S$)=&gt;$T$</code> or by a method convertible to a value of that
type.</p>
<p>Views are applied in three situations:</p>
<ol>
<li>If an expression $e$ is of type $T$, and $T$ does not conform to the
expression&#39;s expected type $\mathit{pt}$. In this case an implicit $v$ is
searched which is applicable to $e$ and whose result type conforms to
$\mathit{pt}$.  The search proceeds as in the case of implicit parameters,
where the implicit scope is the one of <code>$T$ =&gt; $\mathit{pt}$</code>. If
such a view is found, the expression $e$ is converted to
<code>$v$($e$)</code>. </li>
<li>In a selection $e.m$ with $e$ of type $T$, if the selector $m$ does
not denote an accessible member of $T$.  In this case, a view $v$ is searched
which is applicable to $e$ and whose result contains a member named
$m$.  The search proceeds as in the case of implicit parameters, where
the implicit scope is the one of $T$.  If such a view is found, the
selection $e.m$ is converted to <code>$v$($e$).$m$</code>.</li>
<li>In a selection $e.m(\mathit{args})$ with $e$ of type $T$, if the selector
$m$ denotes some member(s) of $T$, but none of these members is applicable to the arguments
$\mathit{args}$. In this case a view $v$ is searched which is applicable to $e$ 
and whose result contains a method $m$ which is applicable to $\mathit{args}$.
The search proceeds as in the case of implicit parameters, where
the implicit scope is the one of $T$.  If such a view is found, the
selection $e.m$ is converted to <code>$v$($e$).$m(\mathit{args})$</code>.</li>
</ol>
<p>The implicit view, if it is found, can accept is argument $e$ as a
call-by-value or as a call-by-name parameter. However, call-by-value
implicits take precedence over call-by-name implicits.</p>
<p>As for implicit parameters, overloading resolution is applied
if there are several possible candidates (of either the call-by-value
or the call-by-name category).</p>
<h3 id="example">Example</h3>
<p>Class <code>scala.Ordered[A]</code> contains a method</p>
<pre><code class="lang-scala">  <span class="hljs-keyword">def</span> &lt;= [B &gt;: A](that: B)(implicit b2ordered: B =&gt; Ordered[B]): Boolean .
</code></pre>
<p>Assume two lists <code>xs</code> and <code>ys</code> of type <code>List[Int]</code>
and assume that the <code>list2ordered</code> and <code>int2ordered</code>
methods defined <a href="#implicit-parameters">here</a> are in scope.
Then the operation</p>
<pre><code class="lang-scala">  xs &lt;= ys
</code></pre>
<p>is legal, and is expanded to:</p>
<pre><code class="lang-scala">  list2ordered(xs)(int2ordered).&lt;=
    (ys)
    (xs =&gt; list2ordered(xs)(int2ordered))
</code></pre>
<p>The first application of <code>list2ordered</code> converts the list
<code>xs</code> to an instance of class <code>Ordered</code>, whereas the second
occurrence is part of an implicit parameter passed to the <code>&lt;=</code>
method.</p>
<h2 id="context-bounds-and-view-bounds">Context Bounds and View Bounds</h2>
<pre><code class="lang-ebnf">  TypeParam ::= (id | ‘_’) [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type] 
                {‘&lt;%’ Type} {‘:’ Type}
</code></pre>
<p>A type parameter $A$ of a method or non-trait class may have one or more view
bounds <code>$A$ &lt;% $T$</code>. In this case the type parameter may be
instantiated to any type $S$ which is convertible by application of a 
view to the bound $T$.</p>
<p>A type parameter $A$ of a method or non-trait class may also have one
or more context bounds <code>$A$ : $T$</code>. In this case the type parameter may be
instantiated to any type $S$ for which <em>evidence</em> exists at the
instantiation point that $S$ satisfies the bound $T$. Such evidence
consists of an implicit value with type $T[S]$.</p>
<p>A method or class containing type parameters with view or context bounds is treated as being
equivalent to a method with implicit parameters. Consider first the case of a
single parameter with view and/or context bounds such as:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> $f$[$A$ &lt;% $T_1$ ... &lt;% $T_m$ : $U_1$ : $U_n$]($\mathit{ps}$): $R$ = ...
</code></pre>
<p>Then the method definition above is expanded to</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> $f$[$A$]($\mathit{ps}$)(implicit $v_1$: $A$ =&gt; $T_1$, ..., $v_m$: $A$ =&gt; $T_m$,
                       $w_1$: $U_1$[$A$], ..., $w_n$: $U_n$[$A$]): $R$ = ...
</code></pre>
<p>where the $v<em>i$ and $w_j$ are fresh names for the newly introduced implicit parameters. These
parameters are called _evidence parameters</em>.</p>
<p>If a class or method has several view- or context-bounded type parameters, each
such type parameter is expanded into evidence parameters in the order
they appear and all the resulting evidence parameters are concatenated
in one implicit parameter section.  Since traits do not take
constructor parameters, this translation does not work for them.
Consequently, type-parameters in traits may not be view- or context-bounded.
Also, a method or class with view- or context bounds may not define any
additional implicit parameters.</p>
<h6 id="example">Example</h6>
<p>The <code>&lt;=</code> method from the <a href="#example-ordered"><code>Ordered</code> example</a> can be declared
more concisely as follows:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">def</span> &lt;= [B &gt;: A &lt;% Ordered[B]](that: B): Boolean
</code></pre>
<h2 id="manifests">Manifests</h2>
<p>Manifests are type descriptors that can be automatically generated by
the Scala compiler as arguments to implicit parameters. The Scala
standard library contains a hierarchy of four manifest classes, 
with <code>OptManifest</code>
at the top. Their signatures follow the outline below.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">OptManifest</span>[+<span class="hljs-title">T</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoManifest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OptManifest</span>[<span class="hljs-title">Nothing</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ClassManifest</span>[<span class="hljs-title">T</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">OptManifest</span>[<span class="hljs-title">T</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Manifest</span>[<span class="hljs-title">T</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassManifest</span>[<span class="hljs-title">T</span>]</span>
</code></pre>
<p>If an implicit parameter of a method or constructor is of a subtype $M[T]$ of
class <code>OptManifest[T]</code>, <em>a manifest is determined for $M[S]$</em>,
according to the following rules.</p>
<p>First if there is already an implicit argument that matches $M[T]$, this
argument is selected.</p>
<p>Otherwise, let $\mathit{Mobj}$ be the companion object <code>scala.reflect.Manifest</code>
if $M$ is trait <code>Manifest</code>, or be
the companion object <code>scala.reflect.ClassManifest</code> otherwise. Let $M&#39;$ be the trait
<code>Manifest</code> if $M$ is trait <code>Manifest</code>, or be the trait <code>OptManifest</code> otherwise.<br>Then the following rules apply.</p>
<ol>
<li>If $T$ is a value class or one of the classes <code>Any</code>, <code>AnyVal</code>, <code>Object</code>,
<code>Null</code>, or <code>Nothing</code>,
a manifest for it is generated by selecting
the corresponding manifest value <code>Manifest.$T$</code>, which exists in the
<code>Manifest</code> module.</li>
<li>If $T$ is an instance of <code>Array[$S$]</code>, a manifest is generated
with the invocation <code>$\mathit{Mobj}$.arrayType[S](m)</code>, where $m$ is the manifest
determined for $M[S]$.</li>
<li>If $T$ is some other class type $S$#$C[U_1, \ldots, U_n]$ where the prefix
type $S$ cannot be statically determined from the class $C$,
a manifest is generated with the invocation <code>$\mathit{Mobj}$.classType[T]($m_0$, classOf[T], $ms$)</code>
where $m_0$ is the manifest determined for $M&#39;[S]$ and $ms$ are the
manifests determined for $M&#39;[U_1], \ldots, M&#39;[U_n]$.</li>
<li>If $T$ is some other class type with type arguments $U_1 , \ldots , U_n$,
a manifest is generated 
with the invocation <code>$\mathit{Mobj}$.classType[T](classOf[T], $ms$)</code>
where $ms$ are the
manifests determined for $M&#39;[U_1] , \ldots , M&#39;[U_n]$.</li>
<li>If $T$ is a singleton type <code>$p$.type</code>, a manifest is generated with
the invocation <code>$\mathit{Mobj}$.singleType[T]($p$)</code> </li>
<li>If $T$ is a refined type $T&#39; { R }$, a manifest is generated for $T&#39;$.
(That is, refinements are never reflected in manifests).</li>
<li>If $T$ is an intersection type
<code>$T_1$ with $, \ldots ,$ with $T_n$</code>
where $n &gt; 1$, the result depends on whether a full manifest is
to be determined or not. 
If $M$ is trait <code>Manifest</code>, then
a manifest is generated with the invocation
<code>Manifest.intersectionType[T]($ms$)</code> where $ms$ are the manifests
determined for $M[T_1] , \ldots , M[T_n]$.
Otherwise, if $M$ is trait <code>ClassManifest</code>, 
then a manifest is generated for the <a href="03-types.html#type-erasure">intersection dominator</a>
of the types $T_1 , \ldots , T_n$.</li>
<li>If $T$ is some other type, then if $M$ is trait <code>OptManifest</code>,
a manifest is generated from the designator <code>scala.reflect.NoManifest</code>.
If $M$ is a type different from <code>OptManifest</code>, a static error results.</li>
</ol>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="./06-expressions.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./08-pattern-matching.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
        <link rel="stylesheet" href="gitbook/style.css">
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="gitbook/app.js"></script>
        
    </body>
</html>
